From 9a4253c97b1953eeef69e0dda1cba5713b12fd96 Mon Sep 17 00:00:00 2001
From: mdeejay <mdjrussia@gmail.com>
Date: Sun, 9 Jul 2017 21:39:01 +0700
Subject: changes for MTK

Change-Id: I934d0bef616a040b00abc97193bb21043d0f34c1

diff --git a/audio_a2dp_hw/Android.mk b/audio_a2dp_hw/Android.mk
index f8a27c14..63d328dc 100644
--- a/audio_a2dp_hw/Android.mk
+++ b/audio_a2dp_hw/Android.mk
@@ -12,13 +12,22 @@ LOCAL_C_INCLUDES += \
 	$(LOCAL_PATH)/../ \
 	$(LOCAL_PATH)/../utils/include
 
-#LOCAL_CFLAGS = -DBT_HOST_IPC_ENABLED
+ifeq ($(MTK_BT_BLUEDROID_PLUS), yes)
+LOCAL_C_INCLUDES += \
+	$(LOCAL_PATH)/mediatek/include
+endif
+
+LOCAL_CFLAGS += -std=c99 $(bdroid_CFLAGS)
+LOCAL_CFLAGS += -DMTK_COMMON
+
 LOCAL_MODULE := audio.a2dp.default
 LOCAL_MODULE_RELATIVE_PATH := hw
 
 LOCAL_SHARED_LIBRARIES := liblog
 LOCAL_STATIC_LIBRARIES := libosi
 
+LOCAL_SHARED_LIBRARIES += libcutils liblog
+
 LOCAL_MODULE_TAGS := optional
 
 LOCAL_CFLAGS += $(bluetooth_CFLAGS)
@@ -26,24 +35,3 @@ LOCAL_CONLYFLAGS += $(bluetooth_CONLYFLAGS)
 LOCAL_CPPFLAGS += $(bluetooth_CPPFLAGS)
 
 include $(BUILD_SHARED_LIBRARY)
-
-##########################################
-include $(CLEAR_VARS)
-
-LOCAL_SRC_FILES := bthost_ipc.c
-
-LOCAL_C_INCLUDES += \
-	$(LOCAL_PATH)/bthost_ipc.h \
-	$(LOCAL_PATH)/../ \
-	$(LOCAL_PATH)/../utils/include
-
-LOCAL_CFLAGS = $(bdroid_CFLAGS)
-
-LOCAL_MODULE := libbthost_if
-LOCAL_MODULE_CLASS := SHARED_LIBRARIES
-LOCAL_SHARED_LIBRARIES := liblog
-LOCAL_STATIC_LIBRARIES := libosi
-
-LOCAL_MODULE_TAGS := optional
-
-include $(BUILD_SHARED_LIBRARY)
diff --git a/audio_a2dp_hw/audio_a2dp_hw.c b/audio_a2dp_hw/audio_a2dp_hw.c
index e1ff28af..643c7de9 100644
--- a/audio_a2dp_hw/audio_a2dp_hw.c
+++ b/audio_a2dp_hw/audio_a2dp_hw.c
@@ -1,9 +1,5 @@
 /******************************************************************************
- *  Copyright (C) 2016, The Linux Foundation. All rights reserved.
  *
- *  Not a Contribution
- ******************************************************************************/
-/*****************************************************************************
  *  Copyright (C) 2009-2012 Broadcom Corporation
  *
  *  Licensed under the Apache License, Version 2.0 (the "License");
@@ -27,12 +23,6 @@
  *  Description:   Implements hal for bluedroid a2dp audio device
  *
  *****************************************************************************/
-//#define BT_AUDIO_SYSTRACE_LOG
-
-#ifdef BT_AUDIO_SYSTRACE_LOG
-#define ATRACE_TAG ATRACE_TAG_ALWAYS
-#define PERF_SYSTRACE 1
-#endif
 
 #define LOG_TAG "bt_a2dp_hw"
 
@@ -60,34 +50,39 @@
 #include "osi/include/osi.h"
 #include "osi/include/socket_utils/sockets.h"
 
-#include <dlfcn.h>
-
-#ifdef BT_HOST_IPC_ENABLED
-#include "bthost_ipc.h"
+#ifdef HAS_MDROID_BUILDCFG
+#include "mdroid_buildcfg.h"
 #endif
 
-#ifdef BT_AUDIO_SYSTRACE_LOG
-#include <cutils/trace.h>
-#endif
+#if MTK_A2DP_PCM_DUMP == TRUE
+#include <cutils/properties.h>
 
-//#define BT_AUDIO_SAMPLE_LOG
+#define INVALID_FD (-1)
+#define MTK_PCM_DUMP_PROPERTY "mtk.a2dp.pcmdump"
 
-#ifdef BT_AUDIO_SAMPLE_LOG
-FILE *outputpcmsamplefile;
-char btoutputfilename [50] = "/data/audio/output_sample";
-static int number =0;
+static const char *pcmfilename = "/sdcard/mtklog/btlog/bt_audio.pcm";
+static int dump_fd = INVALID_FD;
 #endif
+
 /*****************************************************************************
 **  Constants & Macros
 ******************************************************************************/
-
+#if (MTK_COMMON == TRUE)
+#define CTRL_CHAN_RETRY_COUNT 4
+#else
 #define CTRL_CHAN_RETRY_COUNT 3
+#endif
+
 #define USEC_PER_SEC 1000000L
 #define SOCK_SEND_TIMEOUT_MS 2000  /* Timeout for sending */
 #define SOCK_RECV_TIMEOUT_MS 5000  /* Timeout for receiving */
 
+#if (MTK_COMMON == TRUE)
+#define WRITE_POLL_MS 20 * MTK_A2DP_BTIF_MEDIA_TIME_EXT
+#else
 // set WRITE_POLL_MS to 0 for blocking sockets, nonzero for polled non-blocking sockets
 #define WRITE_POLL_MS 20
+#endif
 
 #define CASE_RETURN_STR(const) case const: return #const;
 
@@ -98,10 +93,20 @@ static int number =0;
 #define ERROR(fmt, ...)     LOG_ERROR(LOG_TAG, "%s: " fmt,__FUNCTION__, ## __VA_ARGS__)
 
 #define ASSERTC(cond, msg, val) if (!(cond)) {ERROR("### ASSERT : %s line %d %s (%d) ###", __FILE__, __LINE__, msg, val);}
-//#define BT_HOST_IPC_PATH "/system/lib/hw/bthost-ipc.so"
+
 /*****************************************************************************
 **  Local type definitions
 ******************************************************************************/
+
+typedef enum {
+    AUDIO_A2DP_STATE_STARTING,
+    AUDIO_A2DP_STATE_STARTED,
+    AUDIO_A2DP_STATE_STOPPING,
+    AUDIO_A2DP_STATE_STOPPED,
+    AUDIO_A2DP_STATE_SUSPENDED, /* need explicit set param call to resume (suspend=false) */
+    AUDIO_A2DP_STATE_STANDBY    /* allows write to autoresume */
+} a2dp_state_t;
+
 struct a2dp_stream_in;
 struct a2dp_stream_out;
 
@@ -111,6 +116,23 @@ struct a2dp_audio_device {
     struct a2dp_stream_out *output;
 };
 
+struct a2dp_config {
+    uint32_t                rate;
+    uint32_t                channel_flags;
+    int                     format;
+};
+
+/* move ctrl_fd outside output stream and keep open until HAL unloaded ? */
+
+struct a2dp_stream_common {
+    pthread_mutex_t         lock;
+    int                     ctrl_fd;
+    int                     audio_fd;
+    size_t                  buffer_sz;
+    struct a2dp_config      cfg;
+    a2dp_state_t            state;
+};
+
 struct a2dp_stream_out {
     struct audio_stream_out stream;
     struct a2dp_stream_common common;
@@ -126,10 +148,7 @@ struct a2dp_stream_in {
 /*****************************************************************************
 **  Static variables
 ******************************************************************************/
-#ifdef BT_HOST_IPC_ENABLED
-static void *lib_handle = NULL;
-bt_host_ipc_interface_t *ipc_if = NULL;
-#endif
+
 /*****************************************************************************
 **  Static functions
 ******************************************************************************/
@@ -145,9 +164,8 @@ static size_t out_get_buffer_size(const struct audio_stream *stream);
 ******************************************************************************/
 /* Function used only in debug mode */
 static const char* dump_a2dp_ctrl_event(char event) __attribute__ ((unused));
-#ifndef BT_HOST_IPC_ENABLED
 static void a2dp_open_ctrl_path(struct a2dp_stream_common *common);
-#endif
+
 /*****************************************************************************
 **   Miscellaneous helper functions
 ******************************************************************************/
@@ -161,45 +179,11 @@ static const char* dump_a2dp_ctrl_event(char event)
         CASE_RETURN_STR(A2DP_CTRL_CMD_START)
         CASE_RETURN_STR(A2DP_CTRL_CMD_STOP)
         CASE_RETURN_STR(A2DP_CTRL_CMD_SUSPEND)
-        CASE_RETURN_STR(A2DP_CTRL_CMD_CHECK_STREAM_STARTED)
-        CASE_RETURN_STR(A2DP_CTRL_CMD_OFFLOAD_SUPPORTED)
-        CASE_RETURN_STR(A2DP_CTRL_CMD_OFFLOAD_NOT_SUPPORTED)
         default:
             return "UNKNOWN MSG ID";
     }
 }
 
-static int calc_audiotime(struct a2dp_config cfg, int bytes)
-{
-    int chan_count = popcount(cfg.channel_flags);
-    int bytes_per_sample = 4;
-
-    ASSERTC(cfg.format == AUDIO_FORMAT_PCM_8_24_BIT,
-            "unsupported sample sz", cfg.format);
-
-    return (int)(((int64_t)bytes * (1000000 / (chan_count * bytes_per_sample))) / cfg.rate);
-}
-
-static void ts_error_log(char *tag, int val, int buff_size, struct a2dp_config cfg)
-{
-    struct timespec now;
-    static struct timespec prev = {0,0};
-    unsigned long long now_us;
-    unsigned long long diff_us;
-
-    clock_gettime(CLOCK_MONOTONIC, &now);
-
-    now_us = now.tv_sec*USEC_PER_SEC + now.tv_nsec/1000;
-
-    diff_us = (now.tv_sec - prev.tv_sec) * USEC_PER_SEC + (now.tv_nsec - prev.tv_nsec)/1000;
-    prev = now;
-    if(diff_us > (unsigned long long)(calc_audiotime (cfg, buff_size) + 10000L))
-    {
-       DEBUG("[%s] ts %08lld, diff %08lld, val %d %d", tag, now_us, diff_us, val, buff_size);
-    }
-}
-
-#ifndef BT_HOST_IPC_ENABLED
 /* logs timestamp with microsec precision
    pprev is optional in case a dedicated diff is required */
 static void ts_log(char *tag, int val, struct timespec *pprev_opt)
@@ -229,23 +213,16 @@ static void ts_log(char *tag, int val, struct timespec *pprev_opt)
     }
 }
 
-
-static const char* dump_a2dp_hal_state(int event)
+static int calc_audiotime(struct a2dp_config cfg, int bytes)
 {
-    switch(event)
-    {
-        CASE_RETURN_STR(AUDIO_A2DP_STATE_STARTING)
-        CASE_RETURN_STR(AUDIO_A2DP_STATE_STARTED)
-        CASE_RETURN_STR(AUDIO_A2DP_STATE_STOPPING)
-        CASE_RETURN_STR(AUDIO_A2DP_STATE_STOPPED)
-        CASE_RETURN_STR(AUDIO_A2DP_STATE_SUSPENDED)
-        CASE_RETURN_STR(AUDIO_A2DP_STATE_STANDBY)
-        default:
-            return "UNKNOWN STATE ID";
-    }
+    int chan_count = popcount(cfg.channel_flags);
+
+    ASSERTC(cfg.format == AUDIO_FORMAT_PCM_16_BIT,
+            "unsupported sample sz", cfg.format);
+
+    return (int)(((int64_t)bytes * (1000000 / (chan_count * 2))) / cfg.rate);
 }
 
-//#ifndef BT_HOST_IPC_ENABLED
 /*****************************************************************************
 **
 **   bluedroid stack adaptation
@@ -410,7 +387,7 @@ static int a2dp_command(struct a2dp_stream_common *common, char cmd)
 {
     char ack;
 
-    INFO("A2DP COMMAND %s", dump_a2dp_ctrl_event(cmd));
+    DEBUG("A2DP COMMAND %s", dump_a2dp_ctrl_event(cmd));
 
     if (common->ctrl_fd == AUDIO_SKT_DISCONNECTED) {
         INFO("recovering from previous error");
@@ -438,7 +415,7 @@ static int a2dp_command(struct a2dp_stream_common *common, char cmd)
         return -1;
     }
 
-    INFO("A2DP COMMAND %s DONE STATUS %d", dump_a2dp_ctrl_event(cmd), ack);
+    DEBUG("A2DP COMMAND %s DONE STATUS %d", dump_a2dp_ctrl_event(cmd), ack);
 
     if (ack == A2DP_CTRL_ACK_INCALL_FAILURE)
         return ack;
@@ -452,7 +429,6 @@ static int a2dp_command(struct a2dp_stream_common *common, char cmd)
 
 static int check_a2dp_ready(struct a2dp_stream_common *common)
 {
-    INFO("state %s", dump_a2dp_hal_state(common->state));
     if (a2dp_command(common, A2DP_CTRL_CMD_CHECK_READY) < 0)
     {
         ERROR("check a2dp ready failed");
@@ -539,31 +515,10 @@ static int start_audio_datapath(struct a2dp_stream_common *common)
 {
     INFO("state %d", common->state);
 
-    #ifdef BT_AUDIO_SYSTRACE_LOG
-    char trace_buf[512];
-    #endif
-
-    INFO("state %s", dump_a2dp_hal_state(common->state));
-
     int oldstate = common->state;
     common->state = AUDIO_A2DP_STATE_STARTING;
 
     int a2dp_status = a2dp_command(common, A2DP_CTRL_CMD_START);
-    #ifdef BT_AUDIO_SYSTRACE_LOG
-    snprintf(trace_buf, 32, "start_audio_data_path:");
-    if (PERF_SYSTRACE)
-    {
-        ATRACE_BEGIN(trace_buf);
-    }
-    #endif
-
-
-    #ifdef BT_AUDIO_SYSTRACE_LOG
-    if (PERF_SYSTRACE)
-    {
-        ATRACE_END();
-    }
-    #endif
     if (a2dp_status < 0)
     {
         ERROR("Audiopath start failed (status %d)", a2dp_status);
@@ -575,7 +530,6 @@ static int start_audio_datapath(struct a2dp_stream_common *common)
         goto error;
     }
 
-#ifndef BTA_AV_SPLIT_A2DP_ENABLED
     /* connect socket if not yet connected */
     if (common->audio_fd == AUDIO_SKT_DISCONNECTED)
     {
@@ -585,11 +539,8 @@ static int start_audio_datapath(struct a2dp_stream_common *common)
             ERROR("Audiopath start failed - error opening data socket");
             goto error;
         }
-        common->state = AUDIO_A2DP_STATE_STARTED;
     }
-#else
     common->state = AUDIO_A2DP_STATE_STARTED;
-#endif
     return 0;
 
 error:
@@ -601,7 +552,12 @@ static int stop_audio_datapath(struct a2dp_stream_common *common)
 {
     int oldstate = common->state;
 
-    INFO("state %s", dump_a2dp_hal_state(common->state));
+    INFO("state %d", common->state);
+
+#if (MTK_COMMON == TRUE)
+    if (common->ctrl_fd == AUDIO_SKT_DISCONNECTED)
+        return -1;
+#endif
 
     /* prevent any stray output writes from autostarting the stream
        while stopping audiopath */
@@ -616,18 +572,16 @@ static int stop_audio_datapath(struct a2dp_stream_common *common)
 
     common->state = AUDIO_A2DP_STATE_STOPPED;
 
-#ifndef BTA_AV_SPLIT_A2DP_ENABLED
     /* disconnect audio path */
     skt_disconnect(common->audio_fd);
     common->audio_fd = AUDIO_SKT_DISCONNECTED;
-#endif
 
     return 0;
 }
 
 static int suspend_audio_datapath(struct a2dp_stream_common *common, bool standby)
 {
-    INFO("state %s", dump_a2dp_hal_state(common->state));
+    INFO("state %d", common->state);
 
     if (common->state == AUDIO_A2DP_STATE_STOPPING)
         return -1;
@@ -640,28 +594,15 @@ static int suspend_audio_datapath(struct a2dp_stream_common *common, bool standb
     else
         common->state = AUDIO_A2DP_STATE_SUSPENDED;
 
-#ifndef BTA_AV_SPLIT_A2DP_ENABLED
     /* disconnect audio path */
     skt_disconnect(common->audio_fd);
 
     common->audio_fd = AUDIO_SKT_DISCONNECTED;
-#endif
 
     return 0;
 }
 
 
-static int check_a2dp_stream_started(struct a2dp_stream_out *out)
-{
-   if (a2dp_command(&out->common, A2DP_CTRL_CMD_CHECK_STREAM_STARTED) < 0)
-   {
-       INFO("Btif not in stream state");
-       return -1;
-   }
-   return 0;
-}
-#endif
-
 /*****************************************************************************
 **
 **  audio output callbacks
@@ -673,9 +614,6 @@ static ssize_t out_write(struct audio_stream_out *stream, const void* buffer,
 {
     struct a2dp_stream_out *out = (struct a2dp_stream_out *)stream;
     int sent = -1;
-    #ifdef BT_AUDIO_SYSTRACE_LOG
-    char trace_buf[512];
-    #endif
 
     DEBUG("write %zu bytes (fd %d)", bytes, out->common.audio_fd);
 
@@ -690,11 +628,12 @@ static ssize_t out_write(struct audio_stream_out *stream, const void* buffer,
     if ((out->common.state == AUDIO_A2DP_STATE_STOPPED) ||
         (out->common.state == AUDIO_A2DP_STATE_STANDBY))
     {
-#ifdef BT_HOST_IPC_ENABLED
-        if (ipc_if->start_audio_datapath(&out->common) < 0)
-#else
-        if (start_audio_datapath(&out->common) < 0)
+#if (MTK_COMMON == TRUE)
+        if (out->common.ctrl_fd == AUDIO_SKT_DISCONNECTED) {
+            goto finish;
+        }
 #endif
+        if (start_audio_datapath(&out->common) < 0)
         {
             goto finish;
         }
@@ -704,46 +643,20 @@ static ssize_t out_write(struct audio_stream_out *stream, const void* buffer,
         ERROR("stream not in stopped or standby");
         goto finish;
     }
-    #ifdef BT_AUDIO_SAMPLE_LOG
-    if (outputpcmsamplefile)
-    {
-        fwrite (buffer,1,bytes,outputpcmsamplefile);
-    }
-    #endif
 
-    ts_error_log("a2dp_out_write", bytes, out->common.buffer_sz, out->common.cfg);
-
-    pthread_mutex_unlock(&out->common.lock);
-
-    #ifdef BT_AUDIO_SYSTRACE_LOG
-    snprintf(trace_buf, 32, "out_write:");
-    if (PERF_SYSTRACE)
-    {
-        ATRACE_BEGIN(trace_buf);
+#if MTK_A2DP_PCM_DUMP == TRUE
+    if (buffer != NULL && bytes != 0 && dump_fd != INVALID_FD){
+        write(dump_fd, buffer, bytes);
+        DEBUG("dump a2dp pcm data (%d bytes)", bytes);
     }
-    #endif
+#endif
 
-#ifdef BT_HOST_IPC_ENABLED
-    sent = ipc_if->skt_write(out->common.audio_fd, buffer,  bytes);
-#else
+    pthread_mutex_unlock(&out->common.lock);
     sent = skt_write(out->common.audio_fd, buffer,  bytes);
-#endif
     pthread_mutex_lock(&out->common.lock);
 
-    #ifdef BT_AUDIO_SYSTRACE_LOG
-    if (PERF_SYSTRACE)
-    {
-        ATRACE_END();
-    }
-    #endif
-
-    if (sent == -1)
-    {
-#ifdef BT_HOST_IPC_ENABLED
-        ipc_if->skt_disconnect(out->common.audio_fd);
-#else
+    if (sent == -1) {
         skt_disconnect(out->common.audio_fd);
-#endif
         out->common.audio_fd = AUDIO_SKT_DISCONNECTED;
         if ((out->common.state != AUDIO_A2DP_STATE_SUSPENDED) &&
                 (out->common.state != AUDIO_A2DP_STATE_STOPPING)) {
@@ -773,7 +686,7 @@ static uint32_t out_get_sample_rate(const struct audio_stream *stream)
 {
     struct a2dp_stream_out *out = (struct a2dp_stream_out *)stream;
 
-    INFO("rate %" PRIu32,out->common.cfg.rate);
+    DEBUG("rate %" PRIu32,out->common.cfg.rate);
 
     return out->common.cfg.rate;
 }
@@ -782,7 +695,7 @@ static int out_set_sample_rate(struct audio_stream *stream, uint32_t rate)
 {
     struct a2dp_stream_out *out = (struct a2dp_stream_out *)stream;
 
-    INFO("out_set_sample_rate : %" PRIu32, rate);
+    DEBUG("out_set_sample_rate : %" PRIu32, rate);
 
     if (rate != AUDIO_STREAM_DEFAULT_RATE)
     {
@@ -799,10 +712,14 @@ static size_t out_get_buffer_size(const struct audio_stream *stream)
 {
     struct a2dp_stream_out *out = (struct a2dp_stream_out *)stream;
     // period_size is the AudioFlinger mixer buffer size.
+ #if (MTK_COMMON == TRUE)
+    const size_t period_size = out->common.buffer_sz / AUDIO_STREAM_OUTPUT_BUFFER_PERIODS * MTK_A2DP_BTIF_MEDIA_TIME_EXT;
+ #else
     const size_t period_size = out->common.buffer_sz / AUDIO_STREAM_OUTPUT_BUFFER_PERIODS;
+ #endif
     const size_t mixer_unit_size = 16 /* frames */ * 4 /* framesize */;
 
-    INFO("socket buffer size: %zu  period size: %zu", out->common.buffer_sz, period_size);
+    DEBUG("socket buffer size: %zu  period size: %zu", out->common.buffer_sz, period_size);
     if (period_size % mixer_unit_size != 0) {
         ERROR("period size %zu not a multiple of %zu", period_size, mixer_unit_size);
     }
@@ -830,7 +747,7 @@ static int out_set_format(struct audio_stream *stream, audio_format_t format)
 {
     UNUSED(stream);
     UNUSED(format);
-    INFO("setting format not yet supported (0x%x)", format);
+    DEBUG("setting format not yet supported (0x%x)", format);
     return -ENOSYS;
 }
 
@@ -844,11 +761,7 @@ static int out_standby(struct audio_stream *stream)
     pthread_mutex_lock(&out->common.lock);
     // Do nothing in SUSPENDED state.
     if (out->common.state != AUDIO_A2DP_STATE_SUSPENDED)
-#ifdef BT_HOST_IPC_ENABLED
-        retVal =  ipc_if->suspend_audio_datapath(&out->common, true);
-#else
-        retVal =  suspend_audio_datapath(&out->common, true);
-#endif
+        retVal = suspend_audio_datapath(&out->common, true);
     out->frames_rendered = 0; // rendered is reset, presented is not
     pthread_mutex_unlock (&out->common.lock);
 
@@ -867,129 +780,45 @@ static int out_set_parameters(struct audio_stream *stream, const char *kvpairs)
 {
     struct a2dp_stream_out *out = (struct a2dp_stream_out *)stream;
 
-    INFO("out_set_parameters: state %d", out->common.state);
+    INFO("state %d", out->common.state);
 
     hash_map_t *params = hash_map_utils_new_from_string_params(kvpairs);
     int status = 0;
-    char *keyval;
+
     if (!params)
       return status;
 
+    pthread_mutex_lock(&out->common.lock);
+
     /* dump params */
     hash_map_utils_dump_string_keys_string_values(params);
 
-#ifdef BTA_AV_SPLIT_A2DP_ENABLED
-    keyval = (char *)hash_map_get(params, "A2dpStarted");
-
-    if (keyval != NULL)
-    {
-        INFO("out_set_parameters, param: A2dpStarted");
-        if (strcmp(keyval, "true") == 0)
-        {
-            INFO("out_set_parameters, value: true");
-            pthread_mutex_lock(&out->common.lock);
-            if (out->common.state == AUDIO_A2DP_STATE_SUSPENDED)
-            {
-                INFO("stream suspended");
-                status = -1;
-            }
-            else if ((out->common.state == AUDIO_A2DP_STATE_STOPPED) ||
-                (out->common.state == AUDIO_A2DP_STATE_STANDBY))
-            {
-#ifdef BT_HOST_IPC_ENABLED
-                if (ipc_if->start_audio_datapath(&out->common) < 0)
-#else
-                if (start_audio_datapath(&out->common) < 0)
-#endif
-                {
-                    INFO("stream start failed");
-                    status = -1;
-                }
-            }
-            else if (out->common.state != AUDIO_A2DP_STATE_STARTED)
-            {
-                ERROR("stream not in stopped or standby");
-                status = -1;
-            }
-            pthread_mutex_unlock(&out->common.lock);
-            INFO("stream start completes with status: %d", status);
-        }
-        else if (strcmp(keyval, "false") == 0)
-        {
-            INFO("out_set_parameters, value: false");
-            pthread_mutex_lock(&out->common.lock);
-            if (out->common.state != AUDIO_A2DP_STATE_SUSPENDED)
-#ifdef BT_HOST_IPC_ENABLED
-                status = ipc_if->suspend_audio_datapath(&out->common, true);
-#else
-                status = suspend_audio_datapath(&out->common, true);
-#endif
-            else
-            {
-                ERROR("stream alreday suspended");
-            }
-            pthread_mutex_unlock(&out->common.lock);
-            INFO("stream stop completes with status: %d", status);
-        }
-    }
-#endif
-
-    keyval = (char *)hash_map_get(params, "closing");
+    char *keyval = (char *)hash_map_get(params, "closing");
 
     if (keyval && strcmp(keyval, "true") == 0)
     {
         DEBUG("stream closing, disallow any writes");
-            pthread_mutex_lock(&out->common.lock);
         out->common.state = AUDIO_A2DP_STATE_STOPPING;
-            pthread_mutex_unlock(&out->common.lock);
     }
 
     keyval = (char *)hash_map_get(params, "A2dpSuspended");
 
-    if (keyval)
+    if (keyval && strcmp(keyval, "true") == 0)
     {
-        if (strcmp(keyval, "true") == 0) 
-        {
-            pthread_mutex_lock(&out->common.lock);
-            if (out->common.state == AUDIO_A2DP_STATE_STARTED)
-#ifdef BT_HOST_IPC_ENABLED
-                status = ipc_if->suspend_audio_datapath(&out->common, false);
-#else
-                status = suspend_audio_datapath(&out->common, false);
-#endif
-            else
-            {
-#ifdef BT_HOST_IPC_ENABLED
-                if (ipc_if->check_a2dp_stream_started(&out->common) == 0)
-#else
-                if (check_a2dp_stream_started(out) == 0)
-#endif
-                   /*Btif and A2dp HAL state can be out of sync
-                    *check state of btif and suspend audio.
-                    *Happens when remote initiates start.*/
-#ifdef BT_HOST_IPC_ENABLED
-                    status = ipc_if->suspend_audio_datapath(&out->common, false);
-#else
-                    status = suspend_audio_datapath(&out->common, false);
-#endif
-                else
-                    out->common.state = AUDIO_A2DP_STATE_SUSPENDED;
-            }
-            pthread_mutex_unlock(&out->common.lock);
-        }
-        else
-        {
-            pthread_mutex_lock(&out->common.lock);
-            /* Do not start the streaming automatically. If the phone was streaming
-             * prior to being suspended, the next out_write shall trigger the
-             * AVDTP start procedure */
-            if (out->common.state == AUDIO_A2DP_STATE_SUSPENDED)
-                out->common.state = AUDIO_A2DP_STATE_STANDBY;
-            /* Irrespective of the state, return 0 */
-            pthread_mutex_unlock(&out->common.lock);
-        }
+        if (out->common.state == AUDIO_A2DP_STATE_STARTED)
+            status = suspend_audio_datapath(&out->common, false);
+    }
+    else
+    {
+        /* Do not start the streaming automatically. If the phone was streaming
+         * prior to being suspended, the next out_write shall trigger the
+         * AVDTP start procedure */
+        if (out->common.state == AUDIO_A2DP_STATE_SUSPENDED)
+            out->common.state = AUDIO_A2DP_STATE_STANDBY;
+        /* Irrespective of the state, return 0 */
     }
 
+    pthread_mutex_unlock(&out->common.lock);
     hash_map_free(params);
 
     return status;
@@ -1221,11 +1050,7 @@ static ssize_t in_read(struct audio_stream_in *stream, void* buffer,
     if ((in->common.state == AUDIO_A2DP_STATE_STOPPED) ||
         (in->common.state == AUDIO_A2DP_STATE_STANDBY))
     {
-#ifdef BT_HOST_IPC_ENABLED
-        if (ipc_if->start_audio_datapath(&in->common) < 0)
-#else
         if (start_audio_datapath(&in->common) < 0)
-#endif
         {
             goto error;
         }
@@ -1237,20 +1062,11 @@ static ssize_t in_read(struct audio_stream_in *stream, void* buffer,
     }
 
     pthread_mutex_unlock(&in->common.lock);
-#ifdef BT_HOST_IPC_ENABLED
-    read = ipc_if->skt_read(in->common.audio_fd, buffer, bytes);
-#else
     read = skt_read(in->common.audio_fd, buffer, bytes);
-#endif
     pthread_mutex_lock(&in->common.lock);
-
     if (read == -1)
     {
-#ifdef BT_HOST_IPC_ENABLED
-        ipc_if->skt_disconnect(in->common.audio_fd);
-#else
         skt_disconnect(in->common.audio_fd);
-#endif
         in->common.audio_fd = AUDIO_SKT_DISCONNECTED;
         if ((in->common.state != AUDIO_A2DP_STATE_SUSPENDED) &&
                 (in->common.state != AUDIO_A2DP_STATE_STOPPING)) {
@@ -1329,31 +1145,7 @@ static int adev_open_output_stream(struct audio_hw_device *dev,
 
     if (!out)
         return -ENOMEM;
-    #ifdef BT_AUDIO_SAMPLE_LOG
-    snprintf(btoutputfilename, sizeof(btoutputfilename), "%s%d%s", btoutputfilename, number,".pcm");
-    outputpcmsamplefile = fopen (btoutputfilename, "ab");
-    number++;
-    #endif
-
-#ifdef BT_HOST_IPC_ENABLED
-    lib_handle = dlopen("libbthost_if.so", RTLD_NOW);
-    if (!lib_handle)
-    {
-        INFO("Failed to load bthost-ipc library %s",dlerror());
-        ret = -1;
-        goto err_open;
-    }
-    else
-    {
-        ipc_if = (bt_host_ipc_interface_t*) dlsym(lib_handle,"BTHOST_IPC_INTERFACE");
-        if (!ipc_if)
-        {
-            ERROR("Failed to load BT IPC library symbol");
-            ret  = -1;
-            goto err_open;
-        }
-    }
-#endif
+
     out->stream.common.get_sample_rate = out_get_sample_rate;
     out->stream.common.set_sample_rate = out_set_sample_rate;
     out->stream.common.get_buffer_size = out_get_buffer_size;
@@ -1374,13 +1166,10 @@ static int adev_open_output_stream(struct audio_hw_device *dev,
 
 
     /* initialize a2dp specifics */
-#ifdef BT_HOST_IPC_ENABLED
-    ipc_if->a2dp_stream_common_init(&out->common);
-#else
     a2dp_stream_common_init(&out->common);
-#endif
+
     out->common.cfg.channel_flags = AUDIO_STREAM_DEFAULT_CHANNEL_FLAG;
-    out->common.cfg.format = AUDIO_FORMAT_PCM_8_24_BIT;
+    out->common.cfg.format = AUDIO_STREAM_DEFAULT_FORMAT;
     out->common.cfg.rate = AUDIO_STREAM_DEFAULT_RATE;
 
    /* set output config values */
@@ -1393,11 +1182,7 @@ static int adev_open_output_stream(struct audio_hw_device *dev,
     *stream_out = &out->stream;
     a2dp_dev->output = out;
 
-#ifdef BT_HOST_IPC_ENABLED
-    ipc_if->a2dp_open_ctrl_path(&out->common);
-#else
     a2dp_open_ctrl_path(&out->common);
-#endif
     if (out->common.ctrl_fd == AUDIO_SKT_DISCONNECTED)
     {
         ERROR("ctrl socket failed to connect (%s)", strerror(errno));
@@ -1405,14 +1190,23 @@ static int adev_open_output_stream(struct audio_hw_device *dev,
         goto err_open;
     }
 
-#ifdef BT_HOST_IPC_ENABLED
-    if (ipc_if->a2dp_command(&out->common, A2DP_CTRL_CMD_OFFLOAD_NOT_SUPPORTED) == 0) {
-#else
-    if (a2dp_command(&out->common, A2DP_CTRL_CMD_OFFLOAD_NOT_SUPPORTED) == 0) {
-#endif
-        DEBUG("Streaming mode set successfully");
+#if MTK_A2DP_PCM_DUMP == TRUE
+    char dump_enable[PROPERTY_VALUE_MAX];
+
+    property_get(MTK_PCM_DUMP_PROPERTY, dump_enable, "false");
+
+    if (!strcmp("true", dump_enable)){
+        DEBUG("pcm dump property is true");
+
+        dump_fd = open(pcmfilename, O_WRONLY | O_CREAT | O_TRUNC, S_IRUSR | S_IWUSR | S_IRGRP | S_IWGRP | S_IROTH);
+
+        if (dump_fd == INVALID_FD) {
+          ERROR("%s unable to open '%s': %s", __func__, pcmfilename, strerror(errno));
+        }
     }
-    INFO("success");
+#endif
+
+    DEBUG("success");
     /* Delay to ensure Headset is in proper state when START is initiated
        from DUT immediately after the connection due to ongoing music playback. */
     usleep(250000);
@@ -1436,33 +1230,22 @@ static void adev_close_output_stream(struct audio_hw_device *dev,
 
     pthread_mutex_lock(&out->common.lock);
     if ((out->common.state == AUDIO_A2DP_STATE_STARTED) ||
-            (out->common.state == AUDIO_A2DP_STATE_STOPPING))
-#ifdef BT_HOST_IPC_ENABLED
-        ipc_if->stop_audio_datapath(&out->common);
-#else
+            (out->common.state == AUDIO_A2DP_STATE_STOPPING)) {
         stop_audio_datapath(&out->common);
-#endif
-
-    #ifdef BT_AUDIO_SAMPLE_LOG
-    ALOGV("close file output");
-    fclose (outputpcmsamplefile);
-    #endif
+    }
 
-#ifdef BT_HOST_IPC_ENABLED
-    ipc_if->skt_disconnect(out->common.ctrl_fd);
-#else
     skt_disconnect(out->common.ctrl_fd);
-#endif
     out->common.ctrl_fd = AUDIO_SKT_DISCONNECTED;
-#ifdef BT_HOST_IPC_ENABLED
-    if (lib_handle)
-        dlclose(lib_handle);
-#endif
     free(stream);
     a2dp_dev->output = NULL;
     pthread_mutex_unlock(&out->common.lock);
 
-    INFO("done");
+#if MTK_A2DP_PCM_DUMP == TRUE
+    if (dump_fd != INVALID_FD)
+        close(dump_fd);
+#endif
+
+    DEBUG("done");
 }
 
 static int adev_set_parameters(struct audio_hw_device *dev, const char *kvpairs)
@@ -1474,7 +1257,7 @@ static int adev_set_parameters(struct audio_hw_device *dev, const char *kvpairs)
     if (out == NULL)
         return retval;
 
-
+    INFO("state %d", out->common.state);
 
     retval = out->stream.common.set_parameters((struct audio_stream *)out, kvpairs);
 
@@ -1590,25 +1373,6 @@ static int adev_open_input_stream(struct audio_hw_device *dev,
     if (!in)
         return -ENOMEM;
 
-#ifdef BT_HOST_IPC_ENABLED
-    lib_handle = dlopen("libbthost_if.so", RTLD_NOW);
-    if (!lib_handle)
-    {
-        INFO("Failed to load bthost-ipc library %s",dlerror());
-        ret = -1;
-        goto err_open;
-    }
-    else
-    {
-        ipc_if = (bt_host_ipc_interface_t*) dlsym(lib_handle,"BTHOST_IPC_INTERFACE");
-        if (!ipc_if)
-        {
-            ERROR("Failed to load BT IPC library symbol");
-            ret =  -1;
-            goto err_open;
-        }
-    }
-#endif
     in->stream.common.get_sample_rate = in_get_sample_rate;
     in->stream.common.set_sample_rate = in_set_sample_rate;
     in->stream.common.get_buffer_size = in_get_buffer_size;
@@ -1626,19 +1390,12 @@ static int adev_open_input_stream(struct audio_hw_device *dev,
     in->stream.get_input_frames_lost = in_get_input_frames_lost;
 
     /* initialize a2dp specifics */
-#ifdef BT_HOST_IPC_ENABLED
-    ipc_if->a2dp_stream_common_init(&in->common);
-#else
     a2dp_stream_common_init(&in->common);
-#endif
+
     *stream_in = &in->stream;
     a2dp_dev->input = in;
 
-#ifdef BT_HOST_IPC_ENABLED
-    ipc_if->a2dp_open_ctrl_path(&in->common);
-#else
     a2dp_open_ctrl_path(&in->common);
-#endif
     if (in->common.ctrl_fd == AUDIO_SKT_DISCONNECTED)
     {
         ERROR("ctrl socket failed to connect (%s)", strerror(errno));
@@ -1646,18 +1403,7 @@ static int adev_open_input_stream(struct audio_hw_device *dev,
         goto err_open;
     }
 
-#ifdef BT_HOST_IPC_ENABLED
-    if (ipc_if->a2dp_command(&in->common, A2DP_CTRL_CMD_OFFLOAD_NOT_SUPPORTED) == 0) {
-#else
-    if (a2dp_command(&in->common, A2DP_CTRL_CMD_OFFLOAD_NOT_SUPPORTED) == 0) {
-#endif
-        DEBUG("Streaming mode set successfully");
-    }
-#ifdef BT_HOST_IPC_ENABLED
-    if (ipc_if->a2dp_read_audio_config(&in->common) < 0) {
-#else
     if (a2dp_read_audio_config(&in->common) < 0) {
-#endif
         ERROR("a2dp_read_audio_config failed (%s)", strerror(errno));
         ret = -1;
         goto err_open;
@@ -1684,24 +1430,13 @@ static void adev_close_input_stream(struct audio_hw_device *dev,
     INFO("closing input (state %d)", state);
 
     if ((state == AUDIO_A2DP_STATE_STARTED) || (state == AUDIO_A2DP_STATE_STOPPING))
-#ifdef BT_HOST_IPC_ENABLED
-        ipc_if->stop_audio_datapath(&in->common);
-#else
         stop_audio_datapath(&in->common);
-#endif
 
-#ifdef BT_HOST_IPC_ENABLED
-    ipc_if->skt_disconnect(in->common.ctrl_fd);
-#else
     skt_disconnect(in->common.ctrl_fd);
-#endif
     in->common.ctrl_fd = AUDIO_SKT_DISCONNECTED;
     free(stream);
     a2dp_dev->input = NULL;
-#ifdef BT_HOST_IPC_ENABLED
-    if (lib_handle)
-        dlclose(lib_handle);
-#endif
+
     DEBUG("done");
 }
 
diff --git a/audio_a2dp_hw/audio_a2dp_hw.h b/audio_a2dp_hw/audio_a2dp_hw.h
index 1baac4b6..2fd7bd8a 100644
--- a/audio_a2dp_hw/audio_a2dp_hw.h
+++ b/audio_a2dp_hw/audio_a2dp_hw.h
@@ -1,9 +1,4 @@
 /******************************************************************************
- *  Copyright (C) 2016, The Linux Foundation. All rights reserved.
- *
- *  Not a Contribution
- *****************************************************************************/
-/******************************************************************************
  *
  *  Copyright (C) 2009-2012 Broadcom Corporation
  *
@@ -31,7 +26,7 @@
 
 #ifndef AUDIO_A2DP_HW_H
 #define AUDIO_A2DP_HW_H
-#include <pthread.h>
+
 /*****************************************************************************
 **  Constants & Macros
 ******************************************************************************/
@@ -40,12 +35,7 @@
 #define A2DP_CTRL_PATH "/data/misc/bluedroid/.a2dp_ctrl"
 #define A2DP_DATA_PATH "/data/misc/bluedroid/.a2dp_data"
 
-#ifndef BTA_AV_SPLIT_A2DP_DEF_FREQ_48KHZ
 #define AUDIO_STREAM_DEFAULT_RATE          44100
-#else
-#define AUDIO_STREAM_DEFAULT_RATE          48000
-#endif
-
 #define AUDIO_STREAM_DEFAULT_FORMAT        AUDIO_FORMAT_PCM_16_BIT
 #define AUDIO_STREAM_DEFAULT_CHANNEL_FLAG  AUDIO_CHANNEL_OUT_STEREO
 
@@ -65,7 +55,11 @@
 // 20 * 512 is not sufficient size to smooth the variability for some BT devices,
 // resulting in mixer sleep and throttling. We increase this to 28 * 512 to help
 // reduce the effect of variable data consumption.
+#if (MTK_COMMON == TRUE)
+#define AUDIO_STREAM_OUTPUT_BUFFER_SZ      (32*512)
+#else
 #define AUDIO_STREAM_OUTPUT_BUFFER_SZ      (28*512)
+#endif
 
 // AUDIO_STREAM_OUTPUT_BUFFER_PERIODS controls how the socket buffer is divided
 // for AudioFlinger data delivery. The AudioFlinger mixer delivers data in chunks
@@ -90,14 +84,11 @@
 typedef enum {
     A2DP_CTRL_CMD_NONE,
     A2DP_CTRL_CMD_CHECK_READY,
-    A2DP_CTRL_CMD_CHECK_STREAM_STARTED,
     A2DP_CTRL_CMD_START,
     A2DP_CTRL_CMD_STOP,
     A2DP_CTRL_CMD_SUSPEND,
     A2DP_CTRL_GET_AUDIO_CONFIG,
     A2DP_CTRL_CMD_OFFLOAD_START,
-    A2DP_CTRL_CMD_OFFLOAD_SUPPORTED,
-    A2DP_CTRL_CMD_OFFLOAD_NOT_SUPPORTED,
 } tA2DP_CTRL_CMD;
 
 typedef enum {
@@ -108,33 +99,6 @@ typedef enum {
 } tA2DP_CTRL_ACK;
 
 
-typedef enum {
-    AUDIO_A2DP_STATE_STARTING,
-    AUDIO_A2DP_STATE_STARTED,
-    AUDIO_A2DP_STATE_STOPPING,
-    AUDIO_A2DP_STATE_STOPPED,
-    AUDIO_A2DP_STATE_SUSPENDED, /* need explicit set param call to resume (suspend=false) */
-    AUDIO_A2DP_STATE_STANDBY    /* allows write to autoresume */
-} a2dp_state_t;
-
-struct a2dp_config {
-    uint32_t                rate;
-    uint32_t                channel_flags;
-    int                     format;
-};
-
-/* move ctrl_fd outside output stream and keep open until HAL unloaded ? */
-#define  MAX_CODEC_CFG_SIZE  30
-
-struct a2dp_stream_common {
-    pthread_mutex_t         lock;
-    int                     ctrl_fd;
-    int                     audio_fd;
-    size_t                  buffer_sz;
-    struct a2dp_config      cfg;
-    a2dp_state_t            state;
-    uint8_t                 codec_cfg[MAX_CODEC_CFG_SIZE];
-};
 /*****************************************************************************
 **  Type definitions for callback functions
 ******************************************************************************/
diff --git a/audio_a2dp_hw/bthost_ipc.c b/audio_a2dp_hw/bthost_ipc.c
deleted file mode 100644
index 261f3eae..00000000
--- a/audio_a2dp_hw/bthost_ipc.c
+++ /dev/null
@@ -1,1124 +0,0 @@
-/******************************************************************************
- *  Copyright (C) 2016, The Linux Foundation. All rights reserved.
- *
- *  Not a Contribution
- *****************************************************************************/
-/*****************************************************************************
- *  Copyright (C) 2009-2012 Broadcom Corporation
- *
- *  Licensed under the Apache License, Version 2.0 (the "License");
- *  you may not use this file except in compliance with the License.
- *  You may obtain a copy of the License at:
- *
- *  http://www.apache.org/licenses/LICENSE-2.0
- *
- *  Unless required by applicable law or agreed to in writing, software
- *  distributed under the License is distributed on an "AS IS" BASIS,
- *  WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
- *  See the License for the specific language governing permissions and
- *  limitations under the License.
- *
- ******************************************************************************/
-/*      bthost_ipc.c
- *
- *  Description:   Implements IPC interface between HAL and BT host
- *
- *****************************************************************************/
-
-#include <errno.h>
-#include <inttypes.h>
-#include <pthread.h>
-#include <stdint.h>
-#include <sys/time.h>
-#include <sys/socket.h>
-#include <sys/un.h>
-#include <sys/poll.h>
-#include <sys/errno.h>
-#include <sys/stat.h>
-#include <unistd.h>
-#include <fcntl.h>
-#include <system/audio.h>
-#include <hardware/audio.h>
-
-#include <hardware/hardware.h>
-#include "bthost_ipc.h"
-#include "bt_utils.h"
-#include "osi/include/hash_map.h"
-#include "osi/include/hash_map_utils.h"
-#include "osi/include/log.h"
-#include "osi/include/osi.h"
-#include "osi/include/socket_utils/sockets.h"
-
-#ifdef LOG_TAG
-#undef LOG_TAG
-#endif
-#define LOG_TAG "bthost_ipc"
-#include "osi/include/log.h"
-
-
-static int bt_split_a2dp_enabled = 0;
-/*****************************************************************************
-**  Constants & Macros
-******************************************************************************/
-#define STREAM_START_MAX_RETRY_COUNT 80 /* Retry for 8sec to address IOT issue*/
-#define CTRL_CHAN_RETRY_COUNT 3
-#define USEC_PER_SEC 1000000L
-#define SOCK_SEND_TIMEOUT_MS 2000  /* Timeout for sending */
-#define SOCK_RECV_TIMEOUT_MS 5000  /* Timeout for receiving */
-
-// set WRITE_POLL_MS to 0 for blocking sockets, nonzero for polled non-blocking sockets
-#define WRITE_POLL_MS 20
-
-#define CASE_RETURN_STR(const) case const: return #const;
-
-#define FNLOG()             LOG_VERBOSE(LOG_TAG, "%s", __FUNCTION__);
-#define DEBUG(fmt, ...)     LOG_VERBOSE(LOG_TAG, "%s: " fmt,__FUNCTION__, ## __VA_ARGS__)
-#define INFO(fmt, ...)      LOG_INFO(LOG_TAG, "%s: " fmt,__FUNCTION__, ## __VA_ARGS__)
-#define WARN(fmt, ...)      LOG_WARN(LOG_TAG, "%s: " fmt,__FUNCTION__, ## __VA_ARGS__)
-#define ERROR(fmt, ...)     LOG_ERROR(LOG_TAG, "%s: " fmt,__FUNCTION__, ## __VA_ARGS__)
-
-#define ASSERTC(cond, msg, val) if (!(cond)) {ERROR("### ASSERT : %s line %d %s (%d) ###", __FILE__, __LINE__, msg, val);}
-
-/*****************************************************************************
-**  Local type definitions
-******************************************************************************/
-
-struct a2dp_stream_common audio_stream;
-
-/*****************************************************************************
-**  Static functions
-******************************************************************************/
-
-audio_sbc_encoder_config sbc_codec;
-audio_aptx_encoder_config aptx_codec;
-audio_aac_encoder_config aac_codec;
-/*****************************************************************************
-**  Externs
-******************************************************************************/
-
-/*****************************************************************************
-**  Functions
-******************************************************************************/
-void a2dp_open_ctrl_path(struct a2dp_stream_common *common);
-/*****************************************************************************
-**   Miscellaneous helper functions
-******************************************************************************/
-static const char* dump_a2dp_ctrl_event(char event)
-{
-    switch(event)
-    {
-        CASE_RETURN_STR(A2DP_CTRL_CMD_NONE)
-        CASE_RETURN_STR(A2DP_CTRL_CMD_CHECK_READY)
-        CASE_RETURN_STR(A2DP_CTRL_CMD_START)
-        CASE_RETURN_STR(A2DP_CTRL_CMD_STOP)
-        CASE_RETURN_STR(A2DP_CTRL_CMD_SUSPEND)
-        CASE_RETURN_STR(A2DP_CTRL_CMD_OFFLOAD_SUPPORTED)
-        CASE_RETURN_STR(A2DP_CTRL_CMD_OFFLOAD_NOT_SUPPORTED)
-        CASE_RETURN_STR(A2DP_CTRL_CMD_CHECK_STREAM_STARTED)
-        CASE_RETURN_STR(A2DP_CTRL_GET_CODEC_CONFIG)
-        CASE_RETURN_STR(A2DP_CTRL_GET_MULTICAST_STATUS)
-        CASE_RETURN_STR(A2DP_CTRL_GET_CONNECTION_STATUS)
-        default:
-            return "UNKNOWN MSG ID";
-    }
-}
-
-/* logs timestamp with microsec precision
-   pprev is optional in case a dedicated diff is required */
-static void ts_log(char *tag, int val, struct timespec *pprev_opt)
-{
-    struct timespec now;
-    static struct timespec prev = {0,0};
-    unsigned long long now_us;
-    unsigned long long diff_us;
-    UNUSED(tag);
-    UNUSED(val);
-
-    clock_gettime(CLOCK_MONOTONIC, &now);
-
-    now_us = now.tv_sec*USEC_PER_SEC + now.tv_nsec/1000;
-
-    if (pprev_opt)
-    {
-        diff_us = (now.tv_sec - prev.tv_sec) * USEC_PER_SEC + (now.tv_nsec - prev.tv_nsec)/1000;
-        *pprev_opt = now;
-        DEBUG("[%s] ts %08lld, *diff %08lld, val %d", tag, now_us, diff_us, val);
-    }
-    else
-    {
-        diff_us = (now.tv_sec - prev.tv_sec) * USEC_PER_SEC + (now.tv_nsec - prev.tv_nsec)/1000;
-        prev = now;
-        DEBUG("[%s] ts %08lld, diff %08lld, val %d", tag, now_us, diff_us, val);
-    }
-}
-
-
-static const char* dump_a2dp_hal_state(int event)
-{
-    switch(event)
-    {
-        CASE_RETURN_STR(AUDIO_A2DP_STATE_STARTING)
-        CASE_RETURN_STR(AUDIO_A2DP_STATE_STARTED)
-        CASE_RETURN_STR(AUDIO_A2DP_STATE_STOPPING)
-        CASE_RETURN_STR(AUDIO_A2DP_STATE_STOPPED)
-        CASE_RETURN_STR(AUDIO_A2DP_STATE_SUSPENDED)
-        CASE_RETURN_STR(AUDIO_A2DP_STATE_STANDBY)
-        default:
-            return "UNKNOWN STATE ID";
-    }
-}
-static void* a2dp_codec_parser(uint8_t *codec_cfg, audio_format_t *codec_type)
-{
-    char byte,len;
-    uint8_t *p_cfg = codec_cfg;
-    INFO("%s",__func__);
-    if (codec_cfg[CODEC_OFFSET] == CODEC_TYPE_PCM)
-    {
-        *codec_type = AUDIO_FORMAT_PCM_16_BIT;
-        //For the time being Audio does not require any param to be passed for PCM so returning null
-        return NULL;
-    }
-    else if (codec_cfg[CODEC_OFFSET] == CODEC_TYPE_SBC)
-    {
-        memset(&sbc_codec,0,sizeof(audio_sbc_encoder_config));
-        p_cfg++;//skip dev idx
-        len = *p_cfg++;
-        p_cfg++;//skip media type
-        len--;
-        p_cfg++;
-        len--;
-        byte = *p_cfg++;
-        len--;
-        switch (byte & A2D_SBC_FREQ_MASK)
-        {
-            case A2D_SBC_SAMP_FREQ_48:
-                 sbc_codec.sampling_rate = 48000;
-                 break;
-            case A2D_SBC_SAMP_FREQ_44:
-                 sbc_codec.sampling_rate = 44100;
-                 break;
-            case A2D_SBC_SAMP_FREQ_32:
-                 sbc_codec.sampling_rate = 3200;
-                 break;
-            case A2D_SBC_SAMP_FREQ_16:
-                 sbc_codec.sampling_rate = 16000;
-                 break;
-            default:
-                 ERROR("Unkown sampling rate");
-        }
-
-        switch (byte & A2D_SBC_CHN_MASK)
-        {
-            case A2D_SBC_CH_MD_JOINT:
-                 sbc_codec.channels = 3;
-                 break;
-            case A2D_SBC_CH_MD_STEREO:
-                 sbc_codec.channels = 2;
-                 break;
-            case A2D_SBC_CH_MD_DUAL:
-                 sbc_codec.channels = 1;
-                 break;
-            case A2D_SBC_CH_MD_MONO:
-                 sbc_codec.channels = 0;
-                 break;
-            default:
-                 ERROR("Unknow channel mode");
-        }
-        byte = *p_cfg++;
-        len--;
-        switch (byte & A2D_SBC_BLK_MASK)
-        {
-            case A2D_SBC_BLOCKS_16:
-                sbc_codec.blk_len = 16;
-                break;
-            case A2D_SBC_BLOCKS_12:
-                sbc_codec.blk_len = 12;
-                break;
-            case A2D_SBC_BLOCKS_8:
-                sbc_codec.blk_len = 8;
-                break;
-            case A2D_SBC_BLOCKS_4:
-                sbc_codec.blk_len = 4;
-                break;
-            default:
-                ERROR("Unknown block length");
-        }
-
-        switch (byte & A2D_SBC_SUBBAND_MASK)
-        {
-            case A2D_SBC_SUBBAND_8:
-                sbc_codec.subband = 8;
-                break;
-            case A2D_SBC_SUBBAND_4:
-                sbc_codec.subband = 4;
-                break;
-            default:
-                ERROR("Unknown subband");
-        }
-        switch (byte & A2D_SBC_ALLOC_MASK)
-        {
-            case A2D_SBC_ALLOC_MD_L:
-                sbc_codec.alloc = 1;
-                break;
-            case A2D_SBC_ALLOC_MD_S:
-                sbc_codec.alloc = 2;
-            default:
-                ERROR("Unknown alloc method");
-        }
-        sbc_codec.min_bitpool = *p_cfg++;
-        len--;
-        sbc_codec.max_bitpool = *p_cfg++;
-        len--;
-        if (len == 0)
-            INFO("Copied codec config");
-
-        p_cfg += 2; //skip mtu
-        sbc_codec.bitrate = *p_cfg++;
-        sbc_codec.bitrate |= (*p_cfg++ << 8);
-        sbc_codec.bitrate |= (*p_cfg++ << 16);
-        sbc_codec.bitrate |= (*p_cfg++ << 24);
-        *codec_type = AUDIO_FORMAT_SBC;
-        INFO("SBC: Done copying full codec config");
-        return ((void *)(&sbc_codec));
-    } else if (codec_cfg[CODEC_OFFSET] == CODEC_TYPE_AAC)
-    {
-        uint16_t aac_samp_freq = 0;
-        uint32_t aac_bit_rate = 0;
-        memset(&aac_codec,0,sizeof(audio_aac_encoder_config));
-        p_cfg++;//skip dev idx
-        len = *p_cfg++;
-        p_cfg++;//skip media type
-        len--;
-        p_cfg++;//skip codec type
-        len--;
-        byte = *p_cfg++;
-        len--;
-        switch (byte & A2D_AAC_IE_OBJ_TYPE_MSK)
-        {
-            case A2D_AAC_IE_OBJ_TYPE_MPEG_2_AAC_LC:
-                aac_codec.enc_mode = AUDIO_FORMAT_AAC_SUB_LC;
-                break;
-            case A2D_AAC_IE_OBJ_TYPE_MPEG_4_AAC_LC:
-                aac_codec.enc_mode = AUDIO_FORMAT_AAC_SUB_LC;
-                break;
-            case A2D_AAC_IE_OBJ_TYPE_MPEG_4_AAC_LTP:
-                aac_codec.enc_mode = AUDIO_FORMAT_AAC_SUB_LTP;
-                break;
-            case A2D_AAC_IE_OBJ_TYPE_MPEG_4_AAC_SCA:
-                aac_codec.enc_mode = AUDIO_FORMAT_AAC_SUB_SCALABLE;
-                break;
-            default:
-                ERROR("Unknown encoder mode");
-        }
-        //USE 0 (AAC_LC) as hardcoded value till Audio
-        //define constants
-        aac_codec.enc_mode = 0;
-        //USE LOAS(1) or LATM(4) hardcoded values till
-        //Audio define proper constants
-        aac_codec.format_flag = 4;
-        byte = *p_cfg++;
-        len--;
-        aac_samp_freq = byte << 8; //1st byte of sample_freq
-        byte = *p_cfg++;
-        len--;
-        aac_samp_freq |= byte & 0x00F0; //1st nibble of second byte of samp_freq
-
-        switch (aac_samp_freq) {
-            case 0x8000: aac_codec.sampling_rate = 8000; break;
-            case 0x4000: aac_codec.sampling_rate = 11025; break;
-            case 0x2000: aac_codec.sampling_rate = 12000; break;
-            case 0x1000: aac_codec.sampling_rate = 16000; break;
-            case 0x0800: aac_codec.sampling_rate = 22050; break;
-            case 0x0400: aac_codec.sampling_rate = 24000; break;
-            case 0x0200: aac_codec.sampling_rate = 32000; break;
-            case 0x0100: aac_codec.sampling_rate = 44100; break;
-            case 0x0080: aac_codec.sampling_rate = 48000; break;
-            case 0x0040: aac_codec.sampling_rate = 64000; break;
-            case 0x0020: aac_codec.sampling_rate = 88200; break;
-            case 0x0010: aac_codec.sampling_rate = 96000; break;
-            default:
-                ERROR("Invalid sample_freq: %x", aac_samp_freq);
-        }
-
-        switch (byte & A2D_AAC_IE_CHANNELS_MSK)
-        {
-            case A2D_AAC_IE_CHANNELS_1:
-                 aac_codec.channels = 1;
-                 break;
-            case A2D_AAC_IE_CHANNELS_2:
-                 aac_codec.channels = 2;
-                 break;
-            default:
-                 ERROR("Unknow channel mode");
-        }
-        byte = *p_cfg++; //Move to VBR byte
-        len--;
-        switch (byte & A2D_AAC_IE_VBR_MSK)
-        {
-            case A2D_AAC_IE_VBR:
-                break;
-            default:
-                ERROR("VBR not supported");
-        }
-        aac_bit_rate = 0x7F&byte;
-        //Move it 2nd byte of 32 bit word. leaving the VBR bit
-        aac_bit_rate = aac_bit_rate << 16;
-        byte = *p_cfg++; //Move to 2nd byteof bitrate
-        len--;
-
-        //Move it to 3rd byte of 32bit word
-        aac_bit_rate |= 0x0000FF00 & (((uint32_t)byte)<<8);
-        byte = *p_cfg++; //Move to 3rd byte of bitrate
-        len--;
-
-        aac_bit_rate |= 0x000000FF & (((uint32_t)byte));
-        aac_codec.bitrate = aac_bit_rate;
-
-        *codec_type = AUDIO_FORMAT_AAC;
-        INFO("AAC: Done copying full codec config");
-        return ((void *)(&aac_codec));
-    }
-    else if (codec_cfg[CODEC_OFFSET] == NON_A2DP_CODEC_TYPE)
-    {
-        if (codec_cfg[VENDOR_ID_OFFSET] == VENDOR_APTX &&
-            codec_cfg[CODEC_ID_OFFSET] == APTX_CODEC_ID)
-        {
-            INFO("AptX-classic codec");
-            *codec_type = AUDIO_FORMAT_APTX;
-        }
-        if (codec_cfg[VENDOR_ID_OFFSET] == VENDOR_APTX_HD &&
-            codec_cfg[CODEC_ID_OFFSET] == APTX_HD_CODEC_ID)
-        {
-            INFO("AptX-HD codec");
-            *codec_type = AUDIO_FORMAT_APTX_HD;
-        }
-        memset(&aptx_codec,0,sizeof(audio_aptx_encoder_config));
-        p_cfg++; //skip dev_idx
-        len = *p_cfg++;//LOSC
-        p_cfg++; // Skip media type
-        len--;
-        p_cfg++; //codec_type
-        len--;
-        p_cfg+=4;//skip vendor id
-        len -= 4;
-        p_cfg += 2; //skip codec id
-        len -= 2;
-        byte = *p_cfg++;
-        len--;
-        switch (byte & A2D_APTX_SAMP_FREQ_MASK)
-        {
-            case A2D_APTX_SAMP_FREQ_48:
-                 aptx_codec.sampling_rate = 48000;
-                 break;
-            case A2D_APTX_SAMP_FREQ_44:
-                 aptx_codec.sampling_rate = 44100;
-                 break;
-            default:
-                 ERROR("Unknown sampling rate");
-        }
-        switch (byte & A2D_APTX_CHAN_MASK)
-        {
-            case A2D_APTX_CHAN_STEREO:
-                 aptx_codec.channels = 2;
-                 break;
-            case A2D_APTX_CHAN_MONO:
-                 aptx_codec.channels = 1;
-                 break;
-            default:
-                 ERROR("Unknown channel mode");
-        }
-        if (*codec_type == AUDIO_FORMAT_APTX_HD) {
-            p_cfg += 4;
-            len -= 4;//ignore 4 bytes not used
-        }
-        if (len == 0)
-            INFO("Codec config copied");
-
-        p_cfg += 2; //skip mtu
-
-        aptx_codec.bitrate = *p_cfg++;
-        aptx_codec.bitrate |= (*p_cfg++ << 8);
-        aptx_codec.bitrate |= (*p_cfg++ << 16);
-        aptx_codec.bitrate |= (*p_cfg++ << 24);
-
-        INFO("APTx: Done copying full codec config");
-        return ((void *)&aptx_codec);
-    }
-    return NULL;
-}
-/*****************************************************************************
-**
-**   bluedroid stack adaptation
-**
-*****************************************************************************/
-
-static int skt_connect(char *path, size_t buffer_sz)
-{
-    int ret;
-    int skt_fd;
-    int len;
-
-    INFO("connect to %s (sz %zu)", path, buffer_sz);
-
-    skt_fd = socket(AF_LOCAL, SOCK_STREAM, 0);
-
-    if(osi_socket_local_client_connect(skt_fd, path,
-            ANDROID_SOCKET_NAMESPACE_ABSTRACT, SOCK_STREAM) < 0)
-    {
-        ERROR("failed to connect (%s)", strerror(errno));
-        close(skt_fd);
-        return -1;
-    }
-
-    len = buffer_sz;
-    ret = setsockopt(skt_fd, SOL_SOCKET, SO_SNDBUF, (char*)&len, (int)sizeof(len));
-    if (ret < 0)
-        ERROR("setsockopt failed (%s)", strerror(errno));
-
-    ret = setsockopt(skt_fd, SOL_SOCKET, SO_RCVBUF, (char*)&len, (int)sizeof(len));
-    if (ret < 0)
-        ERROR("setsockopt failed (%s)", strerror(errno));
-
-    /* Socket send/receive timeout value */
-    struct timeval tv;
-    tv.tv_sec = SOCK_SEND_TIMEOUT_MS / 1000;
-    tv.tv_usec = (SOCK_SEND_TIMEOUT_MS % 1000) * 1000;
-
-    ret = setsockopt(skt_fd, SOL_SOCKET, SO_SNDTIMEO, &tv, sizeof(tv));
-    if (ret < 0)
-        ERROR("setsockopt failed (%s)", strerror(errno));
-
-    tv.tv_sec = SOCK_RECV_TIMEOUT_MS / 1000;
-    tv.tv_usec = (SOCK_RECV_TIMEOUT_MS % 1000) * 1000;
-
-    ret = setsockopt(skt_fd, SOL_SOCKET, SO_RCVTIMEO, &tv, sizeof(tv));
-    if (ret < 0)
-        ERROR("setsockopt failed (%s)", strerror(errno));
-
-    INFO("connected to stack fd = %d", skt_fd);
-
-    return skt_fd;
-}
-
-static int skt_read(int fd, void *p, size_t len)
-{
-    ssize_t read;
-
-    FNLOG();
-
-    ts_log("skt_read recv", len, NULL);
-
-    OSI_NO_INTR(read = recv(fd, p, len, MSG_NOSIGNAL));
-    if (read == -1)
-        ERROR("read failed with errno=%d\n", errno);
-
-    return (int)read;
-}
-
-static int skt_write(int fd, const void *p, size_t len)
-{
-    ssize_t sent;
-
-    FNLOG();
-
-    ts_log("skt_write", len, NULL);
-
-    if (WRITE_POLL_MS == 0) {
-        // do not poll, use blocking send
-        OSI_NO_INTR(sent = send(fd, p, len, MSG_NOSIGNAL));
-        if (sent == -1)
-            ERROR("write failed with error(%s)", strerror(errno));
-
-        return (int)sent;
-    }
-
-    // use non-blocking send, poll
-    int ms_timeout = SOCK_SEND_TIMEOUT_MS;
-    size_t count = 0;
-    while (count < len) {
-        OSI_NO_INTR(sent = send(fd, p, len - count, MSG_NOSIGNAL | MSG_DONTWAIT));
-        if (sent == -1) {
-            if (errno != EAGAIN && errno != EWOULDBLOCK) {
-                ERROR("write failed with error(%s)", strerror(errno));
-                return -1;
-            }
-            if (ms_timeout >= WRITE_POLL_MS) {
-                usleep(WRITE_POLL_MS * 1000);
-                ms_timeout -= WRITE_POLL_MS;
-                continue;
-            }
-            WARN("write timeout exceeded, sent %zu bytes", count);
-            return -1;
-        }
-        count += sent;
-        p = (const uint8_t *)p + sent;
-    }
-    return (int)count;
-}
-
-static int skt_disconnect(int fd)
-{
-    INFO("fd %d", fd);
-
-    if (fd != AUDIO_SKT_DISCONNECTED)
-    {
-        shutdown(fd, SHUT_RDWR);
-        close(fd);
-    }
-    return 0;
-}
-
-
-
-/*****************************************************************************
-**
-**  AUDIO CONTROL PATH
-**
-*****************************************************************************/
-
-int a2dp_ctrl_receive(struct a2dp_stream_common *common, void* buffer, int length)
-{
-    ssize_t ret;
-    int i;
-
-    for (i = 0;; i++) {
-        OSI_NO_INTR(ret = recv(common->ctrl_fd, buffer, length, MSG_NOSIGNAL));
-        if (ret > 0) {
-            break;
-        }
-        if (ret == 0) {
-            ERROR("ack failed: peer closed");
-            break;
-        }
-        if (errno != EWOULDBLOCK && errno != EAGAIN) {
-            ERROR("ack failed: error(%s)", strerror(errno));
-            break;
-        }
-        if (i == (CTRL_CHAN_RETRY_COUNT - 1)) {
-            ERROR("ack failed: max retry count");
-            break;
-        }
-        INFO("ack failed (%s), retrying", strerror(errno));
-    }
-    if (ret <= 0) {
-        skt_disconnect(common->ctrl_fd);
-        common->ctrl_fd = AUDIO_SKT_DISCONNECTED;
-    }
-    return ret;
-}
-
-int a2dp_command(struct a2dp_stream_common *common, char cmd)
-{
-    char ack;
-
-    INFO("A2DP COMMAND %s", dump_a2dp_ctrl_event(cmd));
-
-    if (common->ctrl_fd == AUDIO_SKT_DISCONNECTED) {
-        INFO("recovering from previous error");
-        a2dp_open_ctrl_path(common);
-        if (common->ctrl_fd == AUDIO_SKT_DISCONNECTED) {
-            ERROR("failure to open ctrl path");
-            return -1;
-        }
-    }
-
-    /* send command */
-    ssize_t sent;
-    OSI_NO_INTR(sent = send(common->ctrl_fd, &cmd, 1, MSG_NOSIGNAL));
-    if (sent == -1)
-    {
-        ERROR("cmd failed (%s)", strerror(errno));
-        skt_disconnect(common->ctrl_fd);
-        common->ctrl_fd = AUDIO_SKT_DISCONNECTED;
-        return -1;
-    }
-
-    /* wait for ack byte */
-    if (a2dp_ctrl_receive(common, &ack, 1) < 0) {
-        ERROR("A2DP COMMAND %s: no ACK", dump_a2dp_ctrl_event(cmd));
-        return -1;
-    }
-
-    INFO("A2DP COMMAND %s DONE STATUS %d", dump_a2dp_ctrl_event(cmd), ack);
-
-    if (ack == A2DP_CTRL_ACK_INCALL_FAILURE)
-        return ack;
-    if (ack != A2DP_CTRL_ACK_SUCCESS) {
-        ERROR("A2DP COMMAND %s error %d", dump_a2dp_ctrl_event(cmd), ack);
-        return -1;
-    }
-    return 0;
-}
-
-int check_a2dp_ready(struct a2dp_stream_common *common)
-{
-    INFO("state %s", dump_a2dp_hal_state(common->state));
-    if (a2dp_command(common, A2DP_CTRL_CMD_CHECK_READY) < 0)
-    {
-        ERROR("check a2dp ready failed");
-        return -1;
-    }
-    return 0;
-}
-
-int a2dp_read_audio_config(struct a2dp_stream_common *common)
-{
-    uint32_t sample_rate;
-    uint8_t channel_count;
-
-    if (a2dp_command(common, A2DP_CTRL_GET_AUDIO_CONFIG) < 0)
-    {
-        ERROR("check a2dp ready failed");
-        return -1;
-    }
-
-    if (a2dp_ctrl_receive(common, &sample_rate, 4) < 0)
-        return -1;
-    if (a2dp_ctrl_receive(common, &channel_count, 1) < 0)
-        return -1;
-
-    common->cfg.channel_flags = (channel_count == 1 ? AUDIO_CHANNEL_IN_MONO : AUDIO_CHANNEL_IN_STEREO);
-    common->cfg.format = AUDIO_STREAM_DEFAULT_FORMAT;
-    common->cfg.rate = sample_rate;
-
-    INFO("got config %d %d", common->cfg.format, common->cfg.rate);
-
-    return 0;
-}
-
-int a2dp_read_codec_config(struct a2dp_stream_common *common,uint8_t idx)
-{
-    char cmd[2],ack;
-    int i,len = 0;
-    uint8_t *p_codec_cfg = common->codec_cfg;
-    cmd[0] = A2DP_CTRL_GET_CODEC_CONFIG;
-    cmd[1] = idx;
-    INFO("%s",__func__);
-    memset(p_codec_cfg,0,MAX_CODEC_CFG_SIZE);
-    INFO("%s",__func__);
-
-    if (send(common->ctrl_fd, cmd, 2,  MSG_NOSIGNAL) == -1)
-    {
-        ERROR("cmd failed (%s)", strerror(errno));
-        skt_disconnect(common->ctrl_fd);
-        common->ctrl_fd = AUDIO_SKT_DISCONNECTED;
-        return -1;
-    }
-
-    if (a2dp_ctrl_receive(common, &ack, 1) < 0)
-        return -1;
-
-    if (ack != A2DP_CTRL_ACK_SUCCESS)
-    {
-        ERROR("%s: Failed to get ack",__func__);
-        return -1;
-    }
-    if (a2dp_ctrl_receive(common, &len, 1) < 0)
-        return -1;
-    if (a2dp_ctrl_receive(common, p_codec_cfg, len) < 0)
-        return -1;
-
-    INFO("got codec config");
-    p_codec_cfg = common->codec_cfg;
-
-    for (i=0;i<len;i++)
-         INFO("code_config[%d] = %d ", i,*p_codec_cfg++);
-
-    return 0;
-}
-
-int a2dp_get_multicast_status(struct a2dp_stream_common *common, uint8_t *mcast_status,
-                               uint8_t *num_dev)
-{
-    INFO("%s",__func__);
-    if (a2dp_command(common,A2DP_CTRL_GET_MULTICAST_STATUS) < 0)
-    {
-        ERROR("check a2dp ready failed");
-        return -1;
-    }
-    INFO("a2dp_get_multicast_status acked fd = %d",common->ctrl_fd);
-    if (a2dp_ctrl_receive(common, mcast_status, 1) < 0)
-        return -1;
-    if (a2dp_ctrl_receive(common, num_dev, 1) < 0)
-        return -1;
-    INFO("%s: multicast status = %d, num_dev = %d",__func__,*mcast_status,*num_dev);
-    return 0;
-}
-
-void a2dp_open_ctrl_path(struct a2dp_stream_common *common)
-{
-    int i;
-
-    /* retry logic to catch any timing variations on control channel */
-    for (i = 0; i < CTRL_CHAN_RETRY_COUNT; i++)
-    {
-        /* connect control channel if not already connected */
-        if ((common->ctrl_fd = skt_connect(A2DP_CTRL_PATH, common->buffer_sz)) > 0)
-        {
-            /* success, now check if stack is ready */
-            if (check_a2dp_ready(common) == 0)
-                break;
-
-            ERROR("error : a2dp not ready, wait 250 ms and retry");
-            usleep(250000);
-            skt_disconnect(common->ctrl_fd);
-            common->ctrl_fd = AUDIO_SKT_DISCONNECTED;
-        }
-
-        /* ctrl channel not ready, wait a bit */
-        usleep(250000);
-    }
-}
-
-/*****************************************************************************
-**
-** AUDIO DATA PATH
-**
-*****************************************************************************/
-
-void a2dp_stream_common_init(struct a2dp_stream_common *common)
-{
-    pthread_mutexattr_t lock_attr;
-
-    FNLOG();
-
-    pthread_mutexattr_init(&lock_attr);
-    pthread_mutexattr_settype(&lock_attr, PTHREAD_MUTEX_RECURSIVE);
-    pthread_mutex_init(&common->lock, &lock_attr);
-
-    common->ctrl_fd = AUDIO_SKT_DISCONNECTED;
-    common->audio_fd = AUDIO_SKT_DISCONNECTED;
-    common->state = AUDIO_A2DP_STATE_STOPPED;
-
-    /* manages max capacity of socket pipe */
-    common->buffer_sz = AUDIO_STREAM_OUTPUT_BUFFER_SZ;
-    bt_split_a2dp_enabled = false;
-}
-
-int start_audio_datapath(struct a2dp_stream_common *common)
-{
-    INFO("state %d", common->state);
-
-    #ifdef BT_AUDIO_SYSTRACE_LOG
-    char trace_buf[512];
-    #endif
-
-    INFO("state %s", dump_a2dp_hal_state(common->state));
-
-    int oldstate = common->state;
-    common->state = AUDIO_A2DP_STATE_STARTING;
-
-    int a2dp_status = a2dp_command(common, A2DP_CTRL_CMD_START);
-    #ifdef BT_AUDIO_SYSTRACE_LOG
-    snprintf(trace_buf, 32, "start_audio_data_path:");
-    if (PERF_SYSTRACE)
-    {
-        ATRACE_BEGIN(trace_buf);
-    }
-    #endif
-
-
-    #ifdef BT_AUDIO_SYSTRACE_LOG
-    if (PERF_SYSTRACE)
-    {
-        ATRACE_END();
-    }
-    #endif
-    if (a2dp_status < 0)
-    {
-        ERROR("%s Audiopath start failed (status %d)", __func__, a2dp_status);
-        goto error;
-    }
-    else if (a2dp_status == A2DP_CTRL_ACK_INCALL_FAILURE)
-    {
-        ERROR("%s Audiopath start failed - in call, move to suspended", __func__);
-        goto error;
-    }
-    if (!bt_split_a2dp_enabled)
-    {
-        /* connect socket if not yet connected */
-        if (common->audio_fd == AUDIO_SKT_DISCONNECTED)
-        {
-            common->audio_fd = skt_connect(A2DP_DATA_PATH, common->buffer_sz);
-            if (common->audio_fd < 0)
-            {
-                common->state = oldstate;
-                goto error;
-            }
-
-            common->state = AUDIO_A2DP_STATE_STARTED;
-        }
-    }
-    else
-    {
-        common->state = AUDIO_A2DP_STATE_STARTED;
-    }
-
-    return 0;
-error:
-    common->state = oldstate;
-    return -1;
-}
-
-int stop_audio_datapath(struct a2dp_stream_common *common)
-{
-    int oldstate = common->state;
-
-    INFO("state %s", dump_a2dp_hal_state(common->state));
-
-    if (common->ctrl_fd == AUDIO_SKT_DISCONNECTED)
-         return -1;
-
-    /* prevent any stray output writes from autostarting the stream
-       while stopping audiopath */
-    common->state = AUDIO_A2DP_STATE_STOPPING;
-
-    if (a2dp_command(common, A2DP_CTRL_CMD_STOP) < 0)
-    {
-        ERROR("audiopath stop failed");
-        common->state = oldstate;
-        return -1;
-    }
-
-    common->state = AUDIO_A2DP_STATE_STOPPED;
-
-    if (!bt_split_a2dp_enabled)
-    {
-        /* disconnect audio path */
-        skt_disconnect(common->audio_fd);
-        common->audio_fd = AUDIO_SKT_DISCONNECTED;
-    }
-
-    return 0;
-}
-
-int suspend_audio_datapath(struct a2dp_stream_common *common, bool standby)
-{
-    INFO("state %s", dump_a2dp_hal_state(common->state));
-
-
-    if (common->state == AUDIO_A2DP_STATE_STOPPING)
-        return -1;
-
-    if (a2dp_command(common, A2DP_CTRL_CMD_SUSPEND) < 0)
-        return -1;
-
-    if (standby)
-        common->state = AUDIO_A2DP_STATE_STANDBY;
-    else
-        common->state = AUDIO_A2DP_STATE_SUSPENDED;
-
-    if (!bt_split_a2dp_enabled)
-    {
-        /* disconnect audio path */
-        skt_disconnect(common->audio_fd);
-
-        common->audio_fd = AUDIO_SKT_DISCONNECTED;
-    }
-
-    return 0;
-}
-
-int check_a2dp_stream_started(struct a2dp_stream_common *common)
-{
-   if (a2dp_command(common, A2DP_CTRL_CMD_CHECK_STREAM_STARTED) < 0)
-   {
-       INFO("Btif not in stream state");
-       return -1;
-   }
-   return 0;
-}
-static int check_a2dp_open_ready(struct a2dp_stream_common *common)
-{
-    if (a2dp_command(common, A2DP_CTRL_GET_CONNECTION_STATUS) < 0)
-    {
-        INFO("No active a2dp connection");
-        return -1;
-    }
-    return 0;
-}
-int audio_open_ctrl_path()
-{
-    INFO("%s",__func__);
-    a2dp_open_ctrl_path(&audio_stream);
-    if (audio_stream.ctrl_fd != AUDIO_SKT_DISCONNECTED)
-    {
-        INFO("control path opened successfull");
-        return 0;
-    }
-    else
-        INFO("control path open failed");
-    return -1;
-}
-
-int audio_start_stream()
-{
-    int i;
-    INFO("%s: state = %s",__func__,dump_a2dp_hal_state(audio_stream.state));
-
-    if (audio_stream.state == AUDIO_A2DP_STATE_SUSPENDED)
-    {
-        INFO("stream suspended");
-        return -1;
-    }
-    /* Sanity check if the ctrl_fd is valid. If audio_stream_close is not called
-     * from audio hal previously when BT is turned off or device is disconnecte,
-     * and tries to start stream again.
-     */
-    if (check_a2dp_open_ready(&audio_stream) < 0)
-    {
-        if (audio_stream.ctrl_fd != AUDIO_SKT_DISCONNECTED)
-        {
-            ERROR("BTIF is not ready to start stream");
-            return -1;
-        }
-        /* Try to start stream to recover from ctrl skt disconnect*/
-    }
-    for (i = 0; i < STREAM_START_MAX_RETRY_COUNT; i++)
-    {
-        if (start_audio_datapath(&audio_stream) == 0)
-        {
-            INFO("a2dp stream started successfully");
-            break;
-        }
-        if (audio_stream.ctrl_fd == AUDIO_SKT_DISCONNECTED)
-        {
-            INFO("control path is disconnected");
-            break;
-        }
-        INFO("%s: a2dp stream not started,wait 100mse & retry", __func__);
-        usleep(100000);
-    }
-    if (audio_stream.state != AUDIO_A2DP_STATE_STARTED)
-    {
-        ERROR("Failed to start a2dp stream");
-        return -1;
-    }
-    return 0;
-}
-
-int audio_stream_open()
-{
-    INFO("%s",__func__);
-    a2dp_stream_common_init(&audio_stream);
-    a2dp_open_ctrl_path(&audio_stream);
-    bt_split_a2dp_enabled = true;
-    if (audio_stream.ctrl_fd != AUDIO_SKT_DISCONNECTED)
-    {
-        INFO("control path open successful");
-        /*Delay to ensure Headset is in proper state when START is initiated
-        from DUT immediately after the connection due to ongoing music playback. */
-        usleep(250000);
-        a2dp_command(&audio_stream,A2DP_CTRL_CMD_OFFLOAD_SUPPORTED);
-        return 0;
-    }
-    else
-        INFO("control path open failed");
-
-    return -1;
-}
-
-int audio_stream_close()
-{
-    INFO("%s",__func__);
-
-    if (audio_stream.state == AUDIO_A2DP_STATE_STARTED ||
-        audio_stream.state == AUDIO_A2DP_STATE_STOPPING)
-    {
-        INFO("%s: Suspending audio stream",__func__);
-        suspend_audio_datapath(&audio_stream,true);
-    }
-
-    skt_disconnect(audio_stream.ctrl_fd);
-    audio_stream.ctrl_fd = AUDIO_SKT_DISCONNECTED;
-    return 0;
-}
-int audio_stop_stream()
-{
-    INFO("%s",__func__);
-    if (suspend_audio_datapath(&audio_stream, true) == 0)
-    {
-        INFO("audio stop stream successful");
-        return 0;
-    }
-    audio_stream.state = AUDIO_A2DP_STATE_STOPPED;
-    return -1;
-}
-
-int audio_suspend_stream()
-{
-    INFO("%s",__func__);
-    if (suspend_audio_datapath(&audio_stream, false) == 0)
-    {
-        INFO("audio start stream successful");
-        return 0;
-    }
-    return -1;
-}
-
-void audio_handoff_triggered()
-{
-    INFO("%s state = %s",__func__,dump_a2dp_hal_state(audio_stream.state));
-    if (audio_stream.state != AUDIO_A2DP_STATE_STOPPED ||
-        audio_stream.state != AUDIO_A2DP_STATE_STOPPING)
-    {
-        audio_stream.state = AUDIO_A2DP_STATE_STOPPED;
-    }
-}
-
-void clear_a2dpsuspend_flag()
-{
-    INFO("%s: state = %s",__func__,dump_a2dp_hal_state(audio_stream.state));
-    if (audio_stream.state == AUDIO_A2DP_STATE_SUSPENDED)
-        audio_stream.state = AUDIO_A2DP_STATE_STOPPED;
-}
-
-void * audio_get_codec_config(uint8_t *multicast_status, uint8_t *num_dev,
-                              audio_format_t *codec_type)
-{
-    INFO("%s: state = %s",__func__,dump_a2dp_hal_state(audio_stream.state));
-
-    a2dp_get_multicast_status(&audio_stream, multicast_status,num_dev);
-
-    DEBUG("got multicast status = %d dev = %d",*multicast_status,*num_dev);
-    if (a2dp_read_codec_config(&audio_stream, 0) == 0)
-    {
-        return (a2dp_codec_parser(&audio_stream.codec_cfg[0], codec_type));
-    }
-    return NULL;
-}
-
-void* audio_get_next_codec_config(uint8_t idx, audio_format_t *codec_type)
-{
-    INFO("%s",__func__);
-    if (a2dp_read_codec_config(&audio_stream,idx) == 0)
-    {
-        return a2dp_codec_parser(&audio_stream.codec_cfg[0], codec_type);
-    }
-    return NULL;
-}
-//Entry point for dynamic lib
-const bt_host_ipc_interface_t BTHOST_IPC_INTERFACE = {
-    sizeof(bt_host_ipc_interface_t),
-    a2dp_open_ctrl_path,
-    a2dp_stream_common_init,
-    start_audio_datapath,
-    suspend_audio_datapath,
-    stop_audio_datapath,
-    check_a2dp_stream_started,
-    check_a2dp_ready,
-    a2dp_read_audio_config,
-    skt_read,
-    skt_write,
-    skt_disconnect,
-    a2dp_command,
-    audio_stream_open,
-    audio_stream_close,
-    audio_start_stream,
-    audio_stop_stream,
-    audio_suspend_stream,
-    audio_get_codec_config,
-    audio_handoff_triggered,
-    clear_a2dpsuspend_flag,
-    audio_get_next_codec_config
-};
diff --git a/audio_a2dp_hw/bthost_ipc.h b/audio_a2dp_hw/bthost_ipc.h
deleted file mode 100644
index 4110bf4a..00000000
--- a/audio_a2dp_hw/bthost_ipc.h
+++ /dev/null
@@ -1,171 +0,0 @@
-/******************************************************************************
- *  Copyright (C) 2016, The Linux Foundation. All rights reserved.
- *
- *  Not a Contribution
- *****************************************************************************/
-/*****************************************************************************
- *  Copyright (C) 2009-2012 Broadcom Corporation
- *
- *  Licensed under the Apache License, Version 2.0 (the "License");
- *  you may not use this file except in compliance with the License.
- *  You may obtain a copy of the License at:
- *
- *  http://www.apache.org/licenses/LICENSE-2.0
- *
- *  Unless required by applicable law or agreed to in writing, software
- *  distributed under the License is distributed on an "AS IS" BASIS,
- *  WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
- *  See the License for the specific language governing permissions and
- *  limitations under the License.
- *
- ******************************************************************************/
-
-/*****************************************************************************
- *
- *  Filename:      audio_a2dp_hw.h
- *
- *  Description:
- *
- *****************************************************************************/
-#ifndef BT_HOST_IPC_H
-#define BT_HOST_IPC_H
-#include "audio_a2dp_hw.h"
-#include <system/audio.h>
-/*****************************************************************************
-**  Constants & Macros
-******************************************************************************/
-
-#define BT_AUDIO_HARDWARE_INTERFACE "libbthost"
-#define A2DP_CTRL_PATH "/data/misc/bluedroid/.a2dp_ctrl"
-#define A2DP_DATA_PATH "/data/misc/bluedroid/.a2dp_data"
-
-typedef enum {
-    A2DP_CTRL_GET_CODEC_CONFIG = 15,
-    A2DP_CTRL_GET_MULTICAST_STATUS,
-    A2DP_CTRL_GET_CONNECTION_STATUS,
-} tA2DP_CTRL_EXT_CMD;
-
-/*
-codec specific definitions
-*/
-#define CODEC_TYPE_SBC 0x00
-#define CODEC_TYPE_AAC 0x02
-#define NON_A2DP_CODEC_TYPE 0xFF
-#define CODEC_OFFSET 3
-#define VENDOR_ID_OFFSET 4
-#define CODEC_ID_OFFSET (VENDOR_ID_OFFSET + 4)
-#define CODEC_TYPE_PCM 0x05
-
-#ifndef VENDOR_APTX
-#define VENDOR_APTX 0x4F
-#endif
-#ifndef VENDOR_APTX_HD
-#define VENDOR_APTX_HD 0xD7
-#endif
-#ifndef VENDOR_APTX_LL
-#define VENDOR_APTX_LL 0x0A
-#endif
-#ifndef APTX_CODEC_ID
-#define APTX_CODEC_ID 0x01
-#endif
-#ifndef APTX_HD_CODEC_ID
-#define APTX_HD_CODEC_ID 0x24
-#endif
-
-#define A2D_SBC_FREQ_MASK 0xF0
-#define A2D_SBC_CHN_MASK  0x0F
-#define A2D_SBC_BLK_MASK  0xF0
-#define A2D_SBC_SUBBAND_MASK 0x0C
-#define A2D_SBC_ALLOC_MASK 0x03
-#define A2D_SBC_SAMP_FREQ_16     0x80    /* b7:16  kHz */
-#define A2D_SBC_SAMP_FREQ_32     0x40    /* b6:32  kHz */
-#define A2D_SBC_SAMP_FREQ_44     0x20    /* b5:44.1kHz */
-#define A2D_SBC_SAMP_FREQ_48     0x10    /* b4:48  kHz */
-#define A2D_SBC_CH_MD_MONO       0x08    /* b3: mono */
-#define A2D_SBC_CH_MD_DUAL       0x04    /* b2: dual */
-#define A2D_SBC_CH_MD_STEREO     0x02    /* b1: stereo */
-#define A2D_SBC_CH_MD_JOINT      0x01    /* b0: joint stereo */
-#define A2D_SBC_BLOCKS_4         0x80    /* 4 blocks */
-#define A2D_SBC_BLOCKS_8         0x40    /* 8 blocks */
-#define A2D_SBC_BLOCKS_12        0x20    /* 12blocks */
-#define A2D_SBC_BLOCKS_16        0x10    /* 16blocks */
-#define A2D_SBC_SUBBAND_4        0x08    /* b3: 4 */
-#define A2D_SBC_SUBBAND_8        0x04    /* b2: 8 */
-#define A2D_SBC_ALLOC_MD_S       0x02    /* b1: SNR */
-#define A2D_SBC_ALLOC_MD_L       0x01    /* b0: loundess */
-
-/* APTX bitmask helper */
-#define A2D_APTX_SAMP_FREQ_MASK  0xF0
-#define A2D_APTX_SAMP_FREQ_48    0x10
-#define A2D_APTX_SAMP_FREQ_44    0x20
-#define A2D_APTX_CHAN_MASK       0x0F
-#define A2D_APTX_CHAN_STEREO     0x02
-#define A2D_APTX_CHAN_MONO       0x01
-
-
-#define A2D_AAC_IE_OBJ_TYPE_MSK                0xF0    /* b7-b4 Object Type */
-#define A2D_AAC_IE_OBJ_TYPE_MPEG_2_AAC_LC      0x80    /* b7:MPEG-2 AAC LC */
-#define A2D_AAC_IE_OBJ_TYPE_MPEG_4_AAC_LC      0x40    /* b7:MPEG-4 AAC LC */
-#define A2D_AAC_IE_OBJ_TYPE_MPEG_4_AAC_LTP     0x20    /* b7:MPEG-4 AAC LTP */
-#define A2D_AAC_IE_OBJ_TYPE_MPEG_4_AAC_SCA     0x10    /* b7:MPEG-4 AAC SCALABLE */
-
-#define A2D_AAC_IE_CHANNELS_MSK                0x0C
-#define A2D_AAC_IE_CHANNELS_1                  0x08    /* Channel 1 */
-#define A2D_AAC_IE_CHANNELS_2                  0x04    /* Channel 2 */
-
-#define A2D_AAC_IE_VBR_MSK                     0x80
-#define A2D_AAC_IE_VBR                         0x80    /* supported */
-
-typedef struct {
-    uint8_t  codec_type;
-    uint8_t  dev_idx;
-    uint16_t sampling_rate; /*44.1khz,48khz*/
-    uint8_t  chn;           /*0(Mono),1(Dual),2(Stereo),3(JS)*/
-    uint8_t  blk_len;       /*4,8,12,16 */
-    uint8_t  subband;       /*4,8*/
-    uint8_t  alloc;         /*0(Loudness),1(SNR)*/
-    uint8_t  min_bitpool;   /* 2 */
-    uint8_t  max_bitpool;   /*53(44.1khz),51 (48khz) */
-    uint16_t mtu;
-    uint32_t bitrate;
-}tA2DP_SBC_CODEC;
-
-typedef struct {
-    uint8_t  codec_type;
-    uint8_t  dev_idx;
-    uint32_t vendor_id;
-    uint16_t codec_id;
-    uint16_t sampling_rate;
-    uint8_t  chnl;
-    uint8_t  cp;
-    uint16_t mtu;
-    uint32_t bitrate;
-}tA2DP_APTX_CODEC;
-
-typedef struct {
-    /** Set to sizeof(bt_host_ipc_interface_t) */
-    size_t          size;
-    void (*a2dp_open_ctrl_path)(struct a2dp_stream_common *common);
-    void (*a2dp_stream_common_init)(struct a2dp_stream_common *common);
-    int (*start_audio_datapath)(struct a2dp_stream_common *common);
-    int (*suspend_audio_datapath)(struct a2dp_stream_common *common, bool standby);
-    int (*stop_audio_datapath)(struct a2dp_stream_common *common);
-    int (*check_a2dp_stream_started)(struct a2dp_stream_common *common);
-    int (*check_a2dp_ready)(struct a2dp_stream_common *common);
-    int (*a2dp_read_audio_config)(struct a2dp_stream_common *common);
-    int (*skt_read)(int fd,void *buf, size_t bytes);
-    int (*skt_write)(int fd,const void *buf, size_t bytes);
-    int (*skt_disconnect)(int fd);
-    int (*a2dp_command)(struct a2dp_stream_common *common,char cmd);
-    int (*audio_stream_open)(void);
-    int (*audio_stream_close)(void);
-    int (*audio_start_stream)(void);
-    int (*audio_stop_stream)(void);
-    int (*audio_suspend_stream)(void);
-    void* (*audio_get_codec_config)(uint8_t *mcast, uint8_t *num_dev, audio_format_t *codec_type);
-    void (*audio_handoff_triggered)(void);
-    void (*clear_a2dpsuspend_flag)(void);
-    void*(*audio_get_next_codec_config)(uint8_t idx, audio_format_t *codec_type);
-
-} bt_host_ipc_interface_t;
-#endif
diff --git a/audio_a2dp_hw/mediatek/Android.mk b/audio_a2dp_hw/mediatek/Android.mk
new file mode 100644
index 00000000..d99d9f2b
--- /dev/null
+++ b/audio_a2dp_hw/mediatek/Android.mk
@@ -0,0 +1,29 @@
+LOCAL_PATH := $(call my-dir)
+
+include $(CLEAR_VARS)
+
+LOCAL_C_INCLUDES := \
+	$(LOCAL_PATH)/include \
+	$(LOCAL_PATH)/.. \
+	$(LOCAL_PATH)/../include \
+	$(LOCAL_PATH)/../btcore/include \
+	$(LOCAL_PATH)/../stack/include \
+	$(bluetooth_C_INCLUDES)
+
+LOCAL_SRC_FILES := \
+	./conf/btif_config_mtk_util.c \
+	./conf/mdroid_stack_config.c \
+	./hci/twrite.c \
+	./hci/hci_fw_core_dump_ctrl.c \
+	./interop/interop_mtk.c
+
+LOCAL_MODULE := libbt-mtk_cust
+LOCAL_MODULE_TAGS := optional
+LOCAL_MODULE_CLASS := STATIC_LIBRARIES
+
+LOCAL_CFLAGS += $(bluetooth_CFLAGS)
+LOCAL_CONLYFLAGS += $(bluetooth_CONLYFLAGS)
+LOCAL_CPPFLAGS += $(bluetooth_CPPFLAGS)
+
+
+include $(BUILD_STATIC_LIBRARY)
diff --git a/audio_a2dp_hw/mediatek/BUILD.gn b/audio_a2dp_hw/mediatek/BUILD.gn
new file mode 100644
index 00000000..04d477a8
--- /dev/null
+++ b/audio_a2dp_hw/mediatek/BUILD.gn
@@ -0,0 +1,16 @@
+static_library("libbt-mtk_cust") {
+  sources = [
+    "conf/btif_config_mtk_util.c",
+    "conf/mdroid_stack_config.c",
+    "hci/hci_fw_core_dump_ctrl.c",
+    "hci/twrite.c"
+  ]
+
+  include_dirs = [
+    "include",
+    "//",
+    "//include",
+    "//btcore/include",
+    "//stack/include",
+  ]
+}
diff --git a/audio_a2dp_hw/mediatek/conf/btif_config_mtk_util.c b/audio_a2dp_hw/mediatek/conf/btif_config_mtk_util.c
new file mode 100644
index 00000000..23af8c9e
--- /dev/null
+++ b/audio_a2dp_hw/mediatek/conf/btif_config_mtk_util.c
@@ -0,0 +1,1109 @@
+/* Copyright Statement:
+ *
+ * This software/firmware and related documentation ("MediaTek Software") are
+ * protected under relevant copyright laws. The information contained herein
+ * is confidential and proprietary to MediaTek Inc. and/or its licensors.
+ * Without the prior written permission of MediaTek inc. and/or its licensors,
+ * any reproduction, modification, use or disclosure of MediaTek Software,
+ * and information contained herein, in whole or in part, shall be strictly prohibited.
+ *
+ * MediaTek Inc. (C) 2015. All rights reserved.
+ *
+ * BY OPENING THIS FILE, RECEIVER HEREBY UNEQUIVOCALLY ACKNOWLEDGES AND AGREES
+ * THAT THE SOFTWARE/FIRMWARE AND ITS DOCUMENTATIONS ("MEDIATEK SOFTWARE")
+ * RECEIVED FROM MEDIATEK AND/OR ITS REPRESENTATIVES ARE PROVIDED TO RECEIVER ON
+ * AN "AS-IS" BASIS ONLY. MEDIATEK EXPRESSLY DISCLAIMS ANY AND ALL WARRANTIES,
+ * EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE IMPLIED WARRANTIES OF
+ * MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE OR NONINFRINGEMENT.
+ * NEITHER DOES MEDIATEK PROVIDE ANY WARRANTY WHATSOEVER WITH RESPECT TO THE
+ * SOFTWARE OF ANY THIRD PARTY WHICH MAY BE USED BY, INCORPORATED IN, OR
+ * SUPPLIED WITH THE MEDIATEK SOFTWARE, AND RECEIVER AGREES TO LOOK ONLY TO SUCH
+ * THIRD PARTY FOR ANY WARRANTY CLAIM RELATING THERETO. RECEIVER EXPRESSLY ACKNOWLEDGES
+ * THAT IT IS RECEIVER'S SOLE RESPONSIBILITY TO OBTAIN FROM ANY THIRD PARTY ALL PROPER LICENSES
+ * CONTAINED IN MEDIATEK SOFTWARE. MEDIATEK SHALL ALSO NOT BE RESPONSIBLE FOR ANY MEDIATEK
+ * SOFTWARE RELEASES MADE TO RECEIVER'S SPECIFICATION OR TO CONFORM TO A PARTICULAR
+ * STANDARD OR OPEN FORUM. RECEIVER'S SOLE AND EXCLUSIVE REMEDY AND MEDIATEK'S ENTIRE AND
+ * CUMULATIVE LIABILITY WITH RESPECT TO THE MEDIATEK SOFTWARE RELEASED HEREUNDER WILL BE,
+ * AT MEDIATEK'S OPTION, TO REVISE OR REPLACE THE MEDIATEK SOFTWARE AT ISSUE,
+ * OR REFUND ANY SOFTWARE LICENSE FEES OR SERVICE CHARGE PAID BY RECEIVER TO
+ * MEDIATEK FOR SUCH MEDIATEK SOFTWARE AT ISSUE.
+ *
+ * The following software/firmware and/or related documentation ("MediaTek Software")
+ * have been modified by MediaTek Inc. All revisions are subject to any receiver's
+ * applicable license agreements with MediaTek Inc.
+ */
+
+/*****************************************************************************
+ *  Copyright Statement:
+ *  --------------------
+ *  This software is protected by Copyright and the information contained
+ *  herein is confidential. The software may not be copied and the information
+ *  contained herein may not be used or disclosed except with the written
+ *  permission of MediaTek Inc. (C) 2005
+ *
+ *  BY OPENING THIS FILE, BUYER HEREBY UNEQUIVOCALLY ACKNOWLEDGES AND AGREES
+ *  THAT THE SOFTWARE/FIRMWARE AND ITS DOCUMENTATIONS ("MEDIATEK SOFTWARE")
+ *  RECEIVED FROM MEDIATEK AND/OR ITS REPRESENTATIVES ARE PROVIDED TO BUYER ON
+ *  AN "AS-IS" BASIS ONLY. MEDIATEK EXPRESSLY DISCLAIMS ANY AND ALL WARRANTIES,
+ *  EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE IMPLIED WARRANTIES OF
+ *  MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE OR NONINFRINGEMENT.
+ *  NEITHER DOES MEDIATEK PROVIDE ANY WARRANTY WHATSOEVER WITH RESPECT TO THE
+ *  SOFTWARE OF ANY THIRD PARTY WHICH MAY BE USED BY, INCORPORATED IN, OR
+ *  SUPPLIED WITH THE MEDIATEK SOFTWARE, AND BUYER AGREES TO LOOK ONLY TO SUCH
+ *  THIRD PARTY FOR ANY WARRANTY CLAIM RELATING THERETO. MEDIATEK SHALL ALSO
+ *  NOT BE RESPONSIBLE FOR ANY MEDIATEK SOFTWARE RELEASES MADE TO BUYER'S
+ *  SPECIFICATION OR TO CONFORM TO A PARTICULAR STANDARD OR OPEN FORUM.
+ *
+ *  BUYER'S SOLE AND EXCLUSIVE REMEDY AND MEDIATEK'S ENTIRE AND CUMULATIVE
+ *  LIABILITY WITH RESPECT TO THE MEDIATEK SOFTWARE RELEASED HEREUNDER WILL BE,
+ *  AT MEDIATEK'S OPTION, TO REVISE OR REPLACE THE MEDIATEK SOFTWARE AT ISSUE,
+ *  OR REFUND ANY SOFTWARE LICENSE FEES OR SERVICE CHARGE PAID BY BUYER TO
+ *  MEDIATEK FOR SUCH MEDIATEK SOFTWARE AT ISSUE.
+ *
+ *  THE TRANSACTION CONTEMPLATED HEREUNDER SHALL BE CONSTRUED IN ACCORDANCE
+ *  WITH THE LAWS OF THE STATE OF CALIFORNIA, USA, EXCLUDING ITS CONFLICT OF
+ *  LAWS PRINCIPLES.  ANY DISPUTES, CONTROVERSIES OR CLAIMS ARISING THEREOF AND
+ *  RELATED THERETO SHALL BE SETTLED BY ARBITRATION IN SAN FRANCISCO, CA, UNDER
+ *  THE RULES OF THE INTERNATIONAL CHAMBER OF COMMERCE (ICC).
+ *
+ *****************************************************************************/
+
+/************************************************************************************
+ *
+ *  Filename:      btif_config_mtk_util.c
+ *
+ *  Description:   Reads the local BT adapter and remote device properties from
+ *                 Blueangel database and stores into NVRAM storage, typically as
+ *                 conf file in mobile's filesystem
+ *
+ ***********************************************************************************/
+#define LOG_TAG "btif_config_mtk_util"
+
+#include <assert.h>
+#include <stdio.h>
+#include <stdlib.h>
+#include <string.h>
+#include <netinet/in.h>
+#include <errno.h>
+#include <fcntl.h>
+#include <sys/types.h>
+#include <sys/stat.h>
+#include <sys/statfs.h>
+#include <sys/vfs.h>
+#include <unistd.h>
+#include <dirent.h>
+#include <limits.h>
+#include <sys/file.h>
+#include <sys/mman.h>
+
+#include <hardware/bluetooth.h>
+
+#include "osi/include/allocator.h"
+#include "osi/include/config.h"
+#include "osi/include/log.h"
+
+#include "btif_config_mtk_util.h"
+
+/*******************************************************************************
+ ** Constants & Macros
+ ********************************************************************************/
+#ifndef FALSE
+#define TRUE 1
+#define FALSE 0
+#endif
+
+#define BLUEANGEL_PATH "/data/@btmtk/"
+#define BLUEANGEL_PATH_BAK "/data/@btmtk_bak"
+#define BLUEANGEL_DEV_CACHE_PATH "/data/@btmtk/dev_cache"  /* paired device */
+#define BLUEANGEL_HOST_CACHE_PATH  "/data/@btmtk/host_cache"  /* host setting, ex. name, mode */
+#define HID_REMOTE_INFO_DATABASE_FOLDER "/data/@btmtk/HidRemoteDb/" /* BREDR peer HID db*/
+#define BLE_REMOTE_SERVICE_DATABASE_FOLDER "/data/@btmtk/bleRemoteDb/" /* HOGP db*/
+#define BLUEANGEL_DEV_DB_PATH "/data/@btmtk/devdb" /*ssp and smp info*/
+
+#define BTBM_ADP_MAX_NAME_LEN 249  /* 248 byte + 1byte end*/
+#define BTBM_ADP_MAX_SDAP_UUID_NO 30
+#define BTBM_ADP_MAX_SDAP_APP_UUID_NO 5
+#define BTBM_ADP_MAX_PAIRED_LIST_NO 40
+#define HID_MAX_DESC_SIZE 884
+#define BD_ADDR_SIZE 6
+#define LINK_KEY_SIZE 16
+#define DDB_MAX_ENTRIES  40
+
+#define HID_APP_ID_MOUSE      1
+#define HID_APP_ID_KYB      2
+
+/* Group: Minor Device Class - Peripheral Major class */
+#define COD_MINOR_PERIPH_KEYBOARD     0x40
+#define COD_MINOR_PERIPH_POINTING     0x80
+#define COD_MINOR_PERIPH_COMBOKEY     0x000000C0
+
+/* Group: Minor Device Class - ORed with Peripheral Minor Device class */
+#define COD_MINOR_PERIPH_UNCLASSIFIED 0x00000000
+#define COD_MINOR_PERIPH_JOYSTICK     0x00000004
+#define COD_MINOR_PERIPH_GAMEPAD      0x00000008
+#define COD_MINOR_PERIPH_REMOTECTRL   0x0000000C
+#define COD_MINOR_PERIPH_SENSING      0x00000010
+#define COD_MINOR_PERIPH_DIGITIZER    0x00000014
+#define COD_MINOR_PERIPH_CARD_RDR     0x00000018
+#define COD_MINOR_PERIPH_DIGITAL_PAN  0x0000001C
+#define COD_MINOR_PERIPH_HAND_SCANNER 0x00000020
+#define COD_MINOR_PERIPH_HAND_GESTURAL_INPUT 0x00000024
+
+#define BT_LINK_KEY_GAP_TYPE_NO_KEY             0x00
+#define BT_LINK_KEY_GAP_TYPE_COMBINATION_NONE16 0x01
+#define BT_LINK_KEY_GAP_TYPE_COMBINATION_16     0x02
+#define BT_LINK_KEY_GAP_TYPE_UNAUTHENTICATED    0x03
+#define BT_LINK_KEY_GAP_TYPE_AUTHENTICATED      0x04
+
+#define SMP_SEC_NONE                 0
+#define SMP_SEC_UNAUTHENTICATE      (1 << 0)
+#define SMP_SEC_AUTHENTICATED       (1 << 2)
+
+#define BT_DEVICE_TYPE_BREDR   0x01
+#define BT_DEVICE_TYPE_BLE     0x02
+#define BT_DEVICE_TYPE_DUMO    0x03
+
+#define BTA_HH_NV_LOAD_MAX 16
+
+typedef enum
+{
+    BTMTK_BOND_STATE_UNBOND,
+    BTMTK_BOND_STATE_BONDED,
+    BTMTK_BOND_STATE_BONDING,
+} btmtk_bond_state;
+
+typedef enum
+{
+    BTBM_DEVICE_TYPE_LE,
+    BTBM_DEVICE_TYPE_BR_EDR,
+    BTBM_DEVICE_TYPE_BR_EDR_LE
+} btmtk_device_type;
+
+typedef enum
+{
+    SM_KEY_LTK  = 0x01,
+    SM_KEY_EDIV = 0x02,
+    SM_KEY_RAND = 0x04,
+    SM_KEY_IRK  = 0x08,
+    SM_KEY_ADDR = 0x10,
+    SM_KEY_CSRK = 0x20
+} SmKeyType;
+
+typedef enum
+{
+    BT_DEV_TYPE_UNKNOWN,
+    BT_DEV_TYPE_LE,
+    BT_DEV_TYPE_BR_EDR,
+    BT_DEV_TYPE_BR_EDR_LE,
+    NUM_OF_BT_DEV_TYPE,
+} BtDevType;
+
+/************************************************************************************
+ **  Local type definitions
+ ************************************************************************************/
+typedef char bdstr_t[18];
+
+typedef struct config_t config_t;
+
+typedef struct
+{
+    uint32_t lap;
+    uint8_t uap;
+    uint16_t nap;
+} bt_addr_struct;
+
+typedef struct
+{
+    unsigned char scan_mode;
+    char name[BTBM_ADP_MAX_NAME_LEN];
+    unsigned int scan_mode_timeout;
+    bt_addr_struct local_addr;
+} btmtk_host_cache_struct;
+
+typedef struct
+{
+    bt_addr_struct addr;
+    char name[BTBM_ADP_MAX_NAME_LEN];
+    char nickname[BTBM_ADP_MAX_NAME_LEN];
+    unsigned int cod;
+    struct
+    {
+        unsigned char uuid_no;
+        unsigned short uuid[BTBM_ADP_MAX_SDAP_UUID_NO];
+        unsigned short channel[BTBM_ADP_MAX_SDAP_UUID_NO];  /* map to uuid */
+
+        unsigned char app_uuid_no;
+        unsigned char app_uuid[BTBM_ADP_MAX_SDAP_APP_UUID_NO][16];
+        unsigned short app_channel[BTBM_ADP_MAX_SDAP_APP_UUID_NO];  /* map to uuid */
+    } sdp;
+    btmtk_bond_state paired;
+    uint8_t connected;
+    uint8_t trusted;
+    uint8_t legacy_pairing;
+    short rssi;
+    btmtk_device_type device_type;
+} btmtk_device_entry_struct;
+
+#pragma pack(1)
+/*
+   typedef struct
+   {
+   uint16_t vendor_id;
+   uint16_t product_id;
+   uint16_t version;
+   unsigned char countrycode;
+   uint16_t desc_len;
+   char desc_list[HID_MAX_DESC_SIZE];
+   }HidRemoteInfoType;*/
+typedef struct
+{
+    uint16_t     queryFlags;
+    /* Defines which query field contains
+     * valid data.
+     */
+    uint16_t               deviceRelease;
+    /* Vendor specified device release
+     * version.
+     */
+    uint16_t               parserVersion;
+    /* HID parser version for which this
+     * device is designed.
+     */
+    uint8_t                deviceSubclass;
+    /* Device subclass (minor Class of
+     * Device).
+     */
+    uint8_t                countrycode;
+    /*countryCode;  */
+    uint8_t                virtualCable;
+    /* Virtual Cable relationship is
+     * supported.
+     */
+    uint8_t                reconnect;
+    /* Device initiates reconnect.
+    */
+    uint8_t                sdpDisable;
+    /* When TRUE, the device cannot accept
+     * an SDP query when the control/interrupt
+     * channels are connected.
+     */
+    uint8_t                batteryPower;
+    /* The device runs on battery power.
+    */
+    uint8_t                padd;
+
+    uint8_t                remoteWakeup;
+    /* The device can be awakened remotely.
+    */
+    uint16_t               profileVersion;
+    /* Version of the HID profile.
+    */
+    uint16_t               supervTimeout;
+    /* Suggested supervision timeout value
+     * for LMP connections.
+     */
+    uint8_t                normConnectable;
+    /* The device is connectable when no
+     * connection exists.
+     */
+    uint8_t                bootDevice;
+    /* Boot protocol support is provided.
+    */
+    uint32_t               desc_len;
+    /*descriptorLen; */
+    uint8_t               *descriptorList;
+    /* A list of HID descriptors (report or
+     * physical) associated with the device.
+     * Each element of the list is an SDP
+     * data element sequence, and therefore
+     * has a header of two bytes (0x35, len)
+     * which precedes each descriptor.
+     */
+    uint32_t               descriptorLenOffset;
+    /* Offset length  of the HID descriptor list*/
+    uint16_t               vendor_id;
+    /*vendorID*/
+    uint16_t               product_id;
+    /*productID*/
+    char                desc_list[];
+} HidRemoteInfoType;
+typedef struct
+{
+    uint16_t handle;
+    uint8_t desc_uuid_size;
+    uint8_t desc_uuid[2];
+    uint8_t desc_size;
+    uint8_t desc_value[2];
+}descriptor;
+
+typedef  struct
+{
+    uint16_t char_size;
+    uint16_t handle;
+    uint8_t valid;
+    uint8_t properties;
+    uint16_t value_handle;
+    uint8_t value_uuid_size;
+    uint8_t value_uuid[2];
+    uint8_t padding;
+    uint16_t value_size;
+    descriptor desc;
+}characteristic;
+
+typedef struct
+{
+    uint16_t service_size;
+    uint16_t start_handle;
+    uint16_t end_handle;
+    uint8_t uuid_size;
+    uint8_t uuid[2];
+
+    uint16_t include_size;
+    characteristic charc;
+}ble_remote_gattservice;
+
+typedef struct
+{
+    uint8_t rpt_uuid[2];
+    uint8_t rpt_value[2];
+    uint8_t inst_id;
+    uint8_t prop;
+}hid_report_t;
+
+typedef struct
+{
+    char bdAddr[BD_ADDR_SIZE];
+    uint8_t trusted;
+    uint8_t linkKey[LINK_KEY_SIZE];  /* BT4.0 as LTK */
+    uint8_t gampKey[32];
+    uint8_t dampKey[32];
+    uint8_t linkkeyType;
+
+    uint8_t gapKeyType;
+    uint8_t  threebyte_padding[3];
+    BtDevType devType;
+    uint32_t addrType; // LE_ADDR_PUBLIC=0x00, LE_ADDR_RANDOM=0x01
+
+    /* slave key storage when local as master */
+    SmKeyType smKeyType;
+    uint16_t ediv;
+    uint8_t sixbyte_pading[6];
+    uint64_t rand;
+    uint8_t csrk[16];
+    uint8_t irk[16];
+    uint8_t privacy_supported;
+    uint16_t twobyte_padd;
+    uint8_t  onebyte_pad;
+    /* key database when local as slave */
+    SmKeyType distSmKeyType;
+    uint16_t distEDIV;
+    uint8_t sixbyte_pad[6];
+    uint64_t distRAND;
+    uint8_t distLTK[16];
+} BtDeviceRecord;
+
+typedef struct {
+    uint16_t numDdbRecs;
+    uint16_t recordSize;
+    uint32_t padding;
+    BtDeviceRecord devDb[DDB_MAX_ENTRIES];
+} bt_ddb_data;
+
+typedef struct
+{
+    uint8_t ltk[16];
+    uint64_t rand;
+    uint16_t ediv;
+    uint8_t sec_level;
+    uint8_t key_size;
+}penc_keys_t;
+
+typedef struct
+{
+    uint8_t irk[16];
+    uint8_t addr_type;
+    char bdAddr[BD_ADDR_SIZE];
+}pid_keys_t;
+
+/******************************************************************************
+ **  Static functions
+ ******************************************************************************/
+static char* convert_bdaddr2string(const bt_addr_struct *bdaddr, bdstr_t *bdstr);
+static void uuid16_to_uuid128(uint16_t uuid16, bt_uuid_t* uuid128);
+static void uuid_to_string(bt_uuid_t *p_uuid, char *str);
+static void convert_bdaddr2filename (const bt_addr_struct *bdaddr, bdstr_t *bdaddr_str );
+static int load_blueangel_host_info(config_t *config);
+static int load_blueangel_dev_info(config_t *config);
+static void load_blueangel_gatt_info(config_t *config, const bt_addr_struct *bdaddr, bdstr_t bdstr);
+static void load_blueangel_hid_info (config_t *config, const bt_addr_struct *bdaddr, bdstr_t bdstr);
+static void load_blueangel_devdb_info(config_t *config);
+static void load_blueangel_cod_info (config_t *config, unsigned int cod, bdstr_t bdstr);
+static bool btmtk_config_set_bin(config_t *config, const char *section, const char *key, const uint8_t *value, size_t length);
+
+/********************************************************************************
+ **
+ ** Function         open_file_map
+ **
+ ** Description      Opens the required file and maps files into memory.
+ **
+ ** Returns          void
+ **
+ ********************************************************************************/
+static int open_file_map(const char *pathname, const char**map, int* size)
+{
+    struct stat st;
+    st.st_size = 0;
+    int fd;
+    if((fd = open(pathname, O_RDONLY)) >= 0)
+    {
+        if(fstat(fd, &st) == 0 && st.st_size)
+        {
+            *size = st.st_size;
+            *map = (const char*)mmap(NULL, *size, PROT_READ, MAP_SHARED, fd, 0);
+            if(*map && *map != MAP_FAILED)
+            {
+                return fd;
+            }
+        }
+        close(fd);
+    }
+    return -1;
+}
+
+/********************************************************************************
+ **
+ ** Function         close_file_map
+ **
+ ** Description      Unmap files into memory.
+ **
+ ** Returns          void
+ **
+ ********************************************************************************/
+static void close_file_map(int fd, const char* map, int size)
+{
+    munmap((void*)map, size);
+    close(fd);
+}
+
+/********************************************************************************
+ **
+ ** Function         load_blueangel_dev_info
+ **
+ ** Description      Load the paired device settings like Remote device BD Address,
+ **                  remote Name,device type,COD,.... from the path
+ **                  /data/@btmtk/dev_cache and write into bt_config.conf.
+ **
+ ** Returns          void
+ **
+ ********************************************************************************/
+static int load_blueangel_dev_info(config_t *config)
+{
+    char path[25];
+    int size = 0;
+    const char* map = NULL;
+    int num_paired_dev = 0;
+    snprintf(path, sizeof(path), "%s", BLUEANGEL_DEV_CACHE_PATH);
+    int fd = open_file_map(path, &map, &size);
+    if(fd < 0 || size == 0)
+    {
+        LOG_ERROR(LOG_TAG, "open_file_map fail, fd:%d, path:%s, size:%d", fd, path, size);
+        if (fd >= 0)
+            close(fd);
+        return FALSE;
+    }
+    btmtk_device_entry_struct *paired_dev_cache[BTBM_ADP_MAX_PAIRED_LIST_NO];
+    for (int i = 0; i < BTBM_ADP_MAX_PAIRED_LIST_NO; i++)
+    {
+        paired_dev_cache[i] = (btmtk_device_entry_struct *)map;
+        if (paired_dev_cache[i]->addr.lap == 0 && paired_dev_cache[i]->addr.uap == 0 &&
+                paired_dev_cache[i]->addr.nap == 0)
+        {
+            break;
+        }
+        map = map + sizeof(btmtk_device_entry_struct);
+        num_paired_dev++;
+    }
+    bdstr_t bdstr;
+    for (int i =0; i < num_paired_dev; i++)
+    {
+        convert_bdaddr2string(&(paired_dev_cache[i]->addr),&bdstr);
+        config_set_string(config, bdstr, "Name", paired_dev_cache[i]->name);
+        config_set_string(config, bdstr, "Aliase", paired_dev_cache[i]->nickname);
+        config_set_int(config, bdstr, "DevClass", paired_dev_cache[i]->cod);
+        char sdp_uuid[1200] = {0};
+        memset(sdp_uuid, 0, sizeof(sdp_uuid));
+        for (int j =0; j< paired_dev_cache[i]->sdp.uuid_no; j++)
+        {
+            bt_uuid_t remote_uuid;
+            char buf[64] = {0};
+            uuid16_to_uuid128(paired_dev_cache[i]->sdp.uuid[j], &remote_uuid);
+            memset(buf, 0, sizeof(buf));
+            uuid_to_string(&remote_uuid, buf);
+            //debug("[CN]uuid.no: %d, buf: %s", j, buf);
+            sprintf(&sdp_uuid[j * 37], "%s ", buf);
+        }
+        config_set_string(config, bdstr, "Service", sdp_uuid);
+        if (paired_dev_cache[i]->device_type == BTBM_DEVICE_TYPE_LE)
+        {
+            config_set_int(config, bdstr, "DevType", BT_DEVICE_TYPE_BLE);
+            load_blueangel_cod_info (config, paired_dev_cache[i]->cod, bdstr);
+            /* Bluedroid requires HidAttrMask node to load the HidDescriptor but in the Sakura blueangel struct
+             ** there is no mechanism to save the remote HidAttrMask in db. Hence adding the attr mask to 0 since
+             ** bluedroid also set the remote HidAttrMask to 0 for LE devices.
+             */
+            config_set_int(config, bdstr, "HidAttrMask", 0);
+            load_blueangel_gatt_info(config, &(paired_dev_cache[i]->addr), bdstr);
+        }
+        else if (paired_dev_cache[i]->device_type == BTBM_DEVICE_TYPE_BR_EDR)
+        {
+            config_set_int(config, bdstr, "DevType", BT_DEVICE_TYPE_BREDR);
+            if (((paired_dev_cache[i]->cod & 0x1f00) >> 8 == 0x5)) //MajorDeviceClass:Peripheral(mouse,keyboards,.)
+            {
+                load_blueangel_cod_info (config, paired_dev_cache[i]->cod, bdstr);
+                load_blueangel_hid_info (config, &(paired_dev_cache[i]->addr), bdstr);
+            }
+
+        }
+        else if (paired_dev_cache[i]->device_type == BTBM_DEVICE_TYPE_BR_EDR_LE)
+        {
+            config_set_int(config, bdstr, "DevType", BT_DEVICE_TYPE_DUMO);
+            /* To do*/
+        }
+    }
+    load_blueangel_devdb_info(config);
+    close_file_map(fd, map, size);
+    return TRUE;
+}
+
+/********************************************************************************
+ **
+ ** Function         load_blueangel_devdb_info
+ **
+ ** Description      Load the peer ssp and smp settings like linkkey/LTK,
+ Linkey Type, Address Type,Security level,CSRK,IRK,...from
+ **                  the path /data/@btmtk/devdb and write into bt_config.conf.
+ **
+ ** Returns          void
+ **
+ ********************************************************************************/
+static void load_blueangel_devdb_info(config_t *config)
+{
+    char path[22];
+    int size = 0;
+    const char* map = NULL;
+    snprintf(path, sizeof(path), "%s", BLUEANGEL_DEV_DB_PATH);
+
+    int fd = open_file_map(path, &map, &size);
+    if(fd < 0 || size == 0)
+    {
+        LOG_ERROR(LOG_TAG, "open_file_map fail, fd:%d, path:%s, size:%d", fd, path, size);
+        if (fd >= 0)
+            close(fd);
+        return;
+    }
+
+    bt_ddb_data *ddb = (bt_ddb_data*)map;
+    BtDeviceRecord *record;
+    uint16_t count = ddb->numDdbRecs;
+    record = &ddb->devDb[0];
+    while(count > 0)
+    {
+        char bdstr[18];
+        uint8_t link_key[LINK_KEY_SIZE];
+        sprintf(bdstr, "%02x:%02x:%02x:%02x:%02x:%02x",
+                record->bdAddr[5],
+                record->bdAddr[4],
+                record->bdAddr[3],
+                record->bdAddr[2],
+                record->bdAddr[1],
+                record->bdAddr[0]);
+        config_set_int(config, bdstr, "AddrType", record->addrType);
+        if (record->devType == BT_DEV_TYPE_BR_EDR)
+        {
+            config_set_int(config, bdstr, "LinkKeyType", record->linkkeyType);
+            /*reverse the linkkey*/
+            for (int i = 0; i < LINK_KEY_SIZE; i++)
+            {
+                link_key[LINK_KEY_SIZE -1 -i] = record->linkKey[i];
+            }
+            btmtk_config_set_bin(config, bdstr, "LinkKey", (const uint8_t*)link_key,
+                    sizeof(link_key));
+        }
+        else if (record->devType == BT_DEV_TYPE_LE)
+        {
+            penc_keys_t* penc = (penc_keys_t*) malloc(sizeof(penc_keys_t));
+            if (penc != NULL)
+            {
+                memset(penc, 0, sizeof(penc_keys_t));
+                memcpy(penc->ltk, record->linkKey, sizeof(record->linkKey));
+                penc->rand = record->rand;
+                penc->ediv = record->ediv;
+                penc->sec_level = record->gapKeyType;
+                switch (record->gapKeyType)
+                {
+                    case BT_LINK_KEY_GAP_TYPE_UNAUTHENTICATED:
+                        penc->sec_level = SMP_SEC_UNAUTHENTICATE;
+                        break;
+                    case BT_LINK_KEY_GAP_TYPE_AUTHENTICATED:
+                        penc->sec_level = SMP_SEC_AUTHENTICATED;
+                        break;
+                    case BT_LINK_KEY_GAP_TYPE_NO_KEY:
+                        penc->sec_level = SMP_SEC_NONE;
+                        break;
+                    default:
+                        break;
+                }
+                btmtk_config_set_bin(config, bdstr, "LE_KEY_PENC", (const uint8_t*)penc, sizeof(penc_keys_t));
+                btmtk_config_set_bin(config, bdstr, "LE_KEY_LCSRK", (const uint8_t*)record->csrk,
+                        sizeof(record->csrk));
+                free(penc);
+                penc = NULL;
+                if (record->addrType == 0x000001) //check for random addr
+                {
+                    pid_keys_t* pid = (pid_keys_t* )malloc(sizeof(pid_keys_t));
+                    if (pid == NULL) return;
+                    memset(pid, 0, sizeof(pid_keys_t));
+                    memcpy(pid->irk, record->irk, sizeof(record->irk));
+                    memcpy(pid->bdAddr, record->bdAddr, 6);
+                    pid->addr_type = 0x01; //random addr*/
+                    /* Reverse the BD Address */
+                    for (int i = 0; i < BD_ADDR_SIZE; i++)
+                    {
+                        pid->bdAddr[BD_ADDR_SIZE -1 -i] = record->bdAddr[i];
+                    }
+                    btmtk_config_set_bin(config, bdstr, "LE_KEY_PID", (const uint8_t*)pid, sizeof(pid_keys_t));
+                    free(pid);
+                    pid = NULL;
+                }
+            }
+        }
+        count--;
+        record++;
+    }
+    close_file_map(fd, map, size);
+}
+
+/********************************************************************************
+ **
+ ** Function         load_blueangel_gatt_info
+ **
+ ** Description      Load the Remote HOGP records like HID Report,Descriptor from
+ **                  the path /data/@btmtk/bleRemoteDb/<remote BD Addr> and write
+ **                  into bt_config.conf.
+ ** Returns          void
+ **
+ ********************************************************************************/
+static void load_blueangel_gatt_info(config_t *config, const bt_addr_struct *bdaddr, bdstr_t bdstr)
+{
+    bdstr_t bdaddr_str;
+    struct dirent *dptr;
+    DIR *dirp;
+    convert_bdaddr2filename (bdaddr, &bdaddr_str);
+    if((dirp = opendir(BLE_REMOTE_SERVICE_DATABASE_FOLDER)) != NULL)
+    {
+        while((dptr = readdir(dirp)) != NULL)
+        {
+            if(strcmp(dptr->d_name, bdaddr_str) == 0)
+            {
+                char path[45];
+                int size = 0;
+                const char* map = NULL;
+                const char* pos_cur = NULL;
+                const char* pos_file_end = NULL;
+                snprintf (path, sizeof(path), "%s%s", BLE_REMOTE_SERVICE_DATABASE_FOLDER, dptr->d_name);
+                int fd = open_file_map(path, &map, &size);
+                if(fd < 0 || size == 0)
+                {
+                    LOG_ERROR(LOG_TAG, "open_file_map fail, fd:%d, path:%s, size:%d", fd, path, size);
+                    if (fd >= 0)
+                        close(fd);
+                    return;
+                }
+                pos_cur = map;
+                pos_file_end = map + size;
+                char* buf = (char*) malloc(BTA_HH_NV_LOAD_MAX * sizeof(hid_report_t));
+                if(!buf)return;
+                uint8_t srvc_inst_id = 0x00;
+                uint8_t inst_id = 0x00;
+                uint8_t rpt_count = 0;
+
+                while (pos_cur < pos_file_end)
+                {
+                    ble_remote_gattservice* gattservice = (ble_remote_gattservice*)map;
+                    uint8_t rpt_inst_id = 0x00;
+                    uint16_t service_size = gattservice->service_size;
+
+                    /* Decrement service_size to the first service char_size pointer
+                     ** i.e. (sizeof(start_handle)+sizeof(end_handle)+sizeof(uuid_size)+uuid_size
+                     ** +sizeof(include_size)+include_size)
+                     */
+                    uint16_t* include_size_p = &gattservice->include_size;
+                    if(gattservice->uuid_size != 2)
+                        include_size_p = (uint16_t*)(map+ 7 + gattservice->uuid_size);
+                    service_size -= ((5 + gattservice->uuid_size) + (2 + *include_size_p));
+
+                    /* Move the map pointer till the first char_size
+                     ** i.e.(sizeof(service_size)+sizeof(start_handle)+sizeof(end_handle)+
+                     ** sizeof(uuid_size)+uuid_size+sizeof(include_size)+include_size)
+                     */
+                    map = map + (7 + gattservice->uuid_size) + (2 + *include_size_p);
+                    while (service_size > 0)
+                    {
+                        characteristic* charc = (characteristic*)map;
+                        uint16_t char_size = charc->char_size;
+                        /* Move the pointer till the charc value pointer
+                         ** i.e. (sizeof(char_size)+sizeof(handle)+sizeof(valid)+sizeof(properties)
+                         ** +sizeof(value_handle)+sizeof(value_uuid_size)+value_uuid_size+
+                         ** sizeof(padding)+sizeof(value_size)+1)
+                         */
+                        uint16_t* value_size_p = &charc->value_size;
+                        if(charc->value_uuid_size != 2)
+                            value_size_p = (uint16_t*)(map+10+charc->value_uuid_size);
+                        map = map +12+charc->value_uuid_size;
+
+                        /* Check for the Characteristic UUID: HID Report MAP = 0x2a4b*/
+                        if (((charc->value_uuid[0] == 0x4b)&& (charc->value_uuid[1] == 0x2a))
+                                && *value_size_p > 0)
+                        {
+                            const char *value_str = config_get_string(config, bdstr, "HidDescriptor", NULL);
+                            if (!value_str)
+                                btmtk_config_set_bin(config, bdstr, "HidDescriptor", (const uint8_t*)map,
+                                        *value_size_p);
+                        }
+                        map = map + *value_size_p;
+                        /*Decrement to char_size+sizeof(char_size)*/
+                        service_size -= (char_size + 2);
+                        /*Move to the descriptor handle*/
+                        char_size -=
+                            (10 + charc->value_uuid_size + *value_size_p);
+                        while (char_size > 0)
+                        {
+                            descriptor* remote_desc = (descriptor*)map;
+                            uint8_t* desc_size_p = &remote_desc->desc_size;
+                            if(remote_desc->desc_uuid_size !=2)
+                                desc_size_p = (uint8_t*)(map+3+remote_desc->desc_uuid_size);
+                            char_size -=
+                                (4 + remote_desc->desc_uuid_size
+                                 + *desc_size_p);
+                            map = map + (4 + remote_desc->desc_uuid_size
+                                 + *desc_size_p);
+                            /*Check for Report Reference descriptor UUID = 0x2908 */
+                            if (((remote_desc->desc_uuid[0] == 0x08) && (remote_desc->desc_uuid[1] == 0x29)) &&
+                                    (*desc_size_p > 0))
+                            {
+                                hid_report_t* hid_rpt = (hid_report_t*) malloc(sizeof(hid_report_t));
+                                if(!hid_rpt)return;
+                                inst_id = ((srvc_inst_id << 4) | rpt_inst_id);
+                                memcpy(hid_rpt->rpt_uuid, charc->value_uuid, charc->value_uuid_size);
+                                memcpy(hid_rpt->rpt_value, remote_desc->desc_value, 2);
+                                hid_rpt->inst_id = inst_id;
+                                hid_rpt->prop = charc->properties;
+
+                                rpt_inst_id++;
+                                memcpy (buf, hid_rpt, sizeof(hid_report_t));
+                                buf = buf + sizeof(hid_report_t);
+                                free(hid_rpt);
+                                hid_rpt = NULL;
+                                rpt_count++;
+                                map += char_size;
+                                break;
+                            }
+                        }
+                    }
+                    pos_cur = map;
+                    srvc_inst_id++;
+                }
+                buf = buf - (rpt_count * sizeof(hid_report_t));
+                btmtk_config_set_bin(config, bdstr, "HidReport", (const uint8_t*)buf,
+                        (rpt_count * sizeof(hid_report_t)));
+                free(buf);
+                buf = NULL;
+                close_file_map(fd, map, size);
+                break;
+            }
+        }
+        closedir(dirp);
+    }
+    return;
+}
+
+/********************************************************************************
+ **
+ ** Function         load_blueangel_hid_info
+ **
+ ** Description      Load the Remote HID records like HID Report,Descriptor,..
+ **                  from the path /data/@btmtk/HidRemoteDb/<remote BD ADDR> and
+ **                  write into bt_config.conf.
+ **
+ ** Returns          void
+ **
+ ********************************************************************************/
+static void load_blueangel_hid_info (config_t *config, const bt_addr_struct *bdaddr, bdstr_t bdstr)
+{
+    bdstr_t bdaddr_str;
+    struct dirent *dptr;
+    DIR *dirp;
+
+    convert_bdaddr2filename (bdaddr, &bdaddr_str);
+    if((dirp = opendir(HID_REMOTE_INFO_DATABASE_FOLDER)) != NULL)
+    {
+        while((dptr = readdir(dirp)) != NULL)
+        {
+            if(strcmp(dptr->d_name, bdaddr_str) == 0)
+            {
+                char path[45];
+                int size = 0;
+                const char* map = NULL;
+                snprintf(path, sizeof(path), "%s%s", HID_REMOTE_INFO_DATABASE_FOLDER, dptr->d_name);
+                int fd = open_file_map(path, &map, &size);
+                if(fd < 0 || size == 0)
+                {
+                    LOG_ERROR(LOG_TAG, "open_file_map fail, fd:%d, path:%s, size:%d", fd, path, size);
+                    if (fd >= 0)
+                        close(fd);
+                    return;
+                }
+                HidRemoteInfoType* HidRemoteInfo = (HidRemoteInfoType*)map;
+                config_set_int(config, bdstr, "HidVendorId", HidRemoteInfo->vendor_id);
+                config_set_int(config, bdstr, "HidProductId", HidRemoteInfo->product_id);
+                config_set_int(config, bdstr, "HidCountryCode", HidRemoteInfo->countrycode);
+                if(HidRemoteInfo->desc_len > 0)
+                    btmtk_config_set_bin(config, bdstr, "HidDescriptor", (const uint8_t*)HidRemoteInfo->desc_list,
+                            HidRemoteInfo->desc_len);
+                close_file_map(fd, map, size);
+                break;
+            }
+        }
+        closedir(dirp);
+    }
+}
+
+/********************************************************************************
+ **
+ ** Function         load_blueangel_cod_info
+ **
+ ** Description      Set the Hid Sub calss and App Id.
+ **
+ ** Returns          void
+ **
+ ********************************************************************************/
+static void load_blueangel_cod_info (config_t *config, unsigned int cod, bdstr_t bdstr)
+{
+    uint8_t dev_sub_class = (cod & 0x00f0);
+    uint8_t app_id = 0xff; //Bluedroid sets app_id to BTA_ALL_APP_ID for LE devices.
+    config_set_int(config, bdstr, "HidSubClass", dev_sub_class);
+    if(dev_sub_class)
+    {
+        if ((dev_sub_class & COD_MINOR_PERIPH_POINTING) == COD_MINOR_PERIPH_POINTING)
+            app_id = HID_APP_ID_MOUSE;
+        else
+            app_id = HID_APP_ID_KYB;
+    }
+    config_set_int(config, bdstr, "HidAppId", app_id);
+}
+
+/*******************************************************************************
+ **
+ ** Function         load_blueangel_host_info
+ **
+ ** Description      Load the host settings like BD Address, Name, Scantimeout,..
+ **                  from the path /data/@btmtk/host_cache and write into
+ **                  bt_config.conf.
+ **
+ ** Returns          TRUE/FALSE
+ **
+ *******************************************************************************/
+
+static int load_blueangel_host_info(config_t *config)
+{
+    DIR *dirp;
+    int ret = FALSE;
+    if((dirp = opendir(BLUEANGEL_PATH)) != NULL)
+    {
+        char path[25];
+        int size = 0;
+        const char* map = NULL;
+        snprintf(path, sizeof(path), "%s", BLUEANGEL_HOST_CACHE_PATH);
+        int fd = open_file_map(path, &map, &size);
+        if(fd < 0 || size == 0)
+        {
+            LOG_ERROR(LOG_TAG, "open_file_map fail, fd:%d, path:%s, size:%d", fd, path, size);
+            if (fd >= 0)
+                close(fd);
+            return FALSE;
+        }
+        btmtk_host_cache_struct *host_cache = (btmtk_host_cache_struct*)map;
+        /* Convert the BD ADDR into string */
+        bdstr_t bdstr;
+        convert_bdaddr2string(&(host_cache->local_addr),&bdstr);
+
+        config_set_string(config, "Adapter", "Address", bdstr);
+        config_set_int(config, "Adapter", "ScanMode", host_cache->scan_mode);
+        config_set_int(config, "Adapter", "DiscoveryTimeout", host_cache->scan_mode_timeout);
+        config_set_string(config, "Adapter", "Name", host_cache->name);
+
+        //To Do Blueangel supported LE features
+        close_file_map(fd, map, size);
+        closedir(dirp);
+        ret = TRUE;
+    }
+    return ret;
+}
+
+config_t *load_blueangel_cfg()
+{
+    config_t *config = config_new_empty();
+
+    if (!config)
+    {
+        LOG_ERROR(LOG_TAG, "%s unable to allocate config object.", __func__);
+        return NULL;
+    }
+
+    if (load_blueangel_host_info(config))
+    {
+        if (FALSE == load_blueangel_dev_info(config))
+            LOG_WARN(LOG_TAG, "%s: load_blueangel_dev_info fail.", __func__);
+
+        return config;
+    }
+
+    return NULL;
+}
+
+/*******************************************************************************
+ **
+ ** Function         uuid_to_string
+ **
+ ** Description      Convert UUID bytes into string format.
+ **                  Example: 00001812-0000-1000-8000-00805f9b34fb
+ **
+ ** Returns          void
+ **
+ *******************************************************************************/
+static void uuid_to_string(bt_uuid_t *p_uuid, char *str)
+{
+    uint32_t uuid0, uuid4;
+    uint16_t uuid1, uuid2, uuid3, uuid5;
+
+    memcpy(&uuid0, &(p_uuid->uu[0]), 4);
+    memcpy(&uuid1, &(p_uuid->uu[4]), 2);
+    memcpy(&uuid2, &(p_uuid->uu[6]), 2);
+    memcpy(&uuid3, &(p_uuid->uu[8]), 2);
+    memcpy(&uuid4, &(p_uuid->uu[10]), 4);
+    memcpy(&uuid5, &(p_uuid->uu[14]), 2);
+
+    sprintf((char *)str, "%.8x-%.4x-%.4x-%.4x-%.8x%.4x",
+            ntohl(uuid0), ntohs(uuid1),
+            ntohs(uuid2), ntohs(uuid3),
+            ntohl(uuid4), ntohs(uuid5));
+    return;
+}
+
+/*******************************************************************************
+ **
+ ** Function         convert_bdaddr2filename
+ **
+ ** Description      Convert BD Address into filename.
+ **                  Example: 0123456789ab >> 01_23_45_67_89_ab
+ **
+ ** Returns          void
+ **
+ *******************************************************************************/
+static void convert_bdaddr2filename (const bt_addr_struct *bdaddr, bdstr_t *bdaddr_str )
+{
+    uint8_t addr[6];
+    addr[2] = (uint8_t) ((bdaddr->lap & 0x00FF0000) >> 16);
+    addr[1] = (uint8_t) ((bdaddr->lap & 0x0000FF00) >> 8);
+    addr[0] = (uint8_t) (bdaddr->lap & 0x000000FF);
+    addr[3] = (uint8_t) bdaddr->uap;
+    addr[5] = (uint8_t) ((bdaddr->nap & 0xFF00) >> 8);
+    addr[4] = (uint8_t) (bdaddr->nap & 0x00FF);
+    sprintf(*bdaddr_str, "%02X_%02X_%02X_%02X_%02X_%02X",
+            addr[0], addr[1], addr[2], addr[3], addr[4], addr[5]);
+}
+
+/*******************************************************************************
+ **
+ ** Function         uuid16_to_uuid128
+ **
+ ** Description      Convert UUID16 to UUID128.
+ **                  Example: 1812 >> 00001812-0000-1000-8000-00805f9b34fb
+ **
+ ** Returns          void
+ **
+ *******************************************************************************/
+static void uuid16_to_uuid128(uint16_t uuid16, bt_uuid_t* uuid128)
+{
+    uint16_t uuid16_bo;
+    static const uint8_t  sdp_base_uuid[] = {0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x10, 0x00,
+        0x80, 0x00, 0x00, 0x80, 0x5F, 0x9B, 0x34, 0xFB};
+    memset(uuid128, 0, sizeof(bt_uuid_t));
+
+    memcpy(uuid128->uu, sdp_base_uuid, 16);
+    uuid16_bo = ntohs(uuid16);
+    memcpy(uuid128->uu + 2, &uuid16_bo, sizeof(uint16_t));
+}
+
+/*******************************************************************************
+ **
+ ** Function         convert_bdaddr2string
+ **
+ ** Description      Convert BD Address into string format
+ **                  Example: 0123456789ab >> 01:23:45:67:89:ab
+ **
+ ** Returns          string
+ **
+ *******************************************************************************/
+static char* convert_bdaddr2string(const bt_addr_struct *bdaddr, bdstr_t *bdstr)
+{
+    uint8_t addr[6];
+    /* Change the addr from [lap][uap][nap] to [nap][uap][lap] */
+    addr[0] = (uint8_t) ((bdaddr->nap & 0xFF00) >> 8);
+    addr[1] = (uint8_t) (bdaddr->nap & 0x00FF);
+    addr[2] = (uint8_t) bdaddr->uap;
+    addr[3] = (uint8_t) ((bdaddr->lap & 0x00FF0000) >> 16);
+    addr[4] = (uint8_t) ((bdaddr->lap & 0x0000FF00) >> 8);
+    addr[5] = (uint8_t) (bdaddr->lap & 0x000000FF);
+
+    sprintf(*bdstr, "%02x:%02x:%02x:%02x:%02x:%02x",
+            addr[0], addr[1], addr[2],
+            addr[3], addr[4], addr[5]);
+
+    return *bdstr;
+}
+
+/*******************************************************************************
+ **
+ ** Function         btmtk_config_set_bin
+ **
+ ** Description      Convert hex to binary
+ **
+ ** Returns          TRUE/FALSE
+ **
+ *******************************************************************************/
+static bool btmtk_config_set_bin(config_t *config, const char *section, const char *key, const uint8_t *value, size_t length)
+{
+    const char *lookup = "0123456789abcdef";
+
+    assert(config != NULL);
+    assert(section != NULL);
+    assert(key != NULL);
+
+    if (length > 0)
+        assert(value != NULL);
+
+    char *str = (char *)osi_calloc(length * 2 + 1);
+    if (!str)
+        return FALSE;
+
+    for (size_t i = 0; i < length; ++i) {
+        str[(i * 2) + 0] = lookup[(value[i] >> 4) & 0x0F];
+        str[(i * 2) + 1] = lookup[value[i] & 0x0F];
+    }
+
+    config_set_string(config, section, key, str);
+
+    osi_free(str);
+    return TRUE;
+}
diff --git a/audio_a2dp_hw/mediatek/conf/mdroid_stack_config.c b/audio_a2dp_hw/mediatek/conf/mdroid_stack_config.c
new file mode 100644
index 00000000..ba831c0c
--- /dev/null
+++ b/audio_a2dp_hw/mediatek/conf/mdroid_stack_config.c
@@ -0,0 +1,294 @@
+#define LOG_TAG "mdroid_stack_config"
+#include <assert.h>
+#include <errno.h>
+#include <stdbool.h>
+#include <stdio.h>
+#include <string.h>
+
+#include "osi/include/config.h"
+#include "osi/include/log.h"
+#include "osi/include/list.h"
+#include "stack_config.h"
+#include "mdroid_buildcfg.h"
+#include "mdroid_stack_config.h"
+
+
+#if MTK_STACK_CONFIG_LOG == TRUE
+const char *BTLOG_FWLOG_HCI_CMD1 = "C1";
+const char *BTLOG_FWLOG_HCI_CMD2 = "C2";
+#endif /* MTK_STACK_CONFIG_LOG */
+
+#if MTK_STACK_CONFIG == TRUE
+#define CONFIG_MTK_CONF_SECTION "MtkBtConf"
+static const char *STACK_CONF_OVERRIDE_KEY = "MtkStackConfigOverride";
+static const char *EXTFILE_OVERRIDE_TMPKEY = "OverrideConf"; /* easy to parse /sdcard/btsc, it's not a key in config */
+
+#define CONFIG_MTK_FWLOG_SECTION "MtkBtFWLog"
+
+static const char *BTSNOOP_TURNED_ON_KEY = "BtSnoopLogOutput";
+
+#if MTK_STACK_CONFIG_DEFAULT_OVERRIDE == TRUE
+const char *BTDefaultConfOverrideFile = "bt_stack.conf.sqc";
+#endif
+
+/**
+ * Override default configure file /etc/bluetooth/bt_stack.conf
+ *
+ * Current Design:
+ *  1. Upper Layer or User control the config file path written in sdcard/btrc
+ *  2. Here override the stack configure according to the preset configure
+ *
+ * TODO:
+ * 1. Move config relevant definition to local. e.g. MTK_STACK_CONFIG_FPATH_LEN
+ * 2. Use system property to control the log mode
+ */
+bool parse_override_cfg(config_t * config) {
+  FILE * target_file = NULL;
+  char str_ovconf_fpath[MTK_STACK_CONFIG_FPATH_LEN] = { '\0' };
+  const char *p_redir_ovconf_fpath = NULL;
+  char * p_fpath = NULL;
+  char prefix_fpath1[MTK_STACK_CONFIG_FPATH_LEN] = "/etc/bluetooth/";
+  char str_redir_ov_fpath[MTK_STACK_CONFIG_FPATH_LEN] = { '\0' };
+  bool b_override = false;
+
+  if (config == NULL) {
+    LOG_ERROR(LOG_TAG, "%s Override fail. The default config content is NULL.", __func__);
+    return b_override;
+  }
+
+  /* MtkStackConfigOverride = /scard/btsc in bt_stack.conf */
+  strlcpy(str_redir_ov_fpath, config_get_string(config, CONFIG_MTK_CONF_SECTION, STACK_CONF_OVERRIDE_KEY, ""), sizeof(str_redir_ov_fpath));
+
+  LOG_INFO("%s M_BTCONF redir file is \"%s\"", __func__, str_redir_ov_fpath);
+
+  p_redir_ovconf_fpath = str_redir_ov_fpath;
+
+  target_file = fopen(p_redir_ovconf_fpath, "rt");
+  if (!target_file) {
+    LOG_INFO("%s M_BTCONF open redir-file %s fails!", __func__, p_redir_ovconf_fpath);
+
+#if MTK_STACK_CONFIG_DEFAULT_OVERRIDE == TRUE
+    LOG_INFO("%s M_BTCONF set the override default config: %s!", __func__, BTDefaultConfOverrideFile);
+    strlcpy(str_ovconf_fpath, BTDefaultConfOverrideFile, sizeof(str_ovconf_fpath));
+#else
+    /* MTK_STACK_CONFIG_DEFAULT_OVERRIDE is not defined or MTK_STACK_CONFIG_DEFAULT_OVERRIDE == 0 */
+    return false; /* Don't override config - keep it as default config of bluedroid */
+#endif
+
+  } else {
+      fclose(target_file);
+
+      config_t *redir_config = config_new(p_redir_ovconf_fpath);
+      if (redir_config) {
+          /* copy ov filepath from /scard/btsc */
+          strlcpy(str_ovconf_fpath, config_get_string(redir_config, CONFIG_DEFAULT_SECTION, EXTFILE_OVERRIDE_TMPKEY, ""), sizeof(str_ovconf_fpath));
+
+          config_free(redir_config);
+      }
+  }
+
+  LOG_INFO("%s M_BTCONF OverrideConf= %s", __func__, str_ovconf_fpath);
+
+  if (str_ovconf_fpath[0] != '\0') {
+    FILE *test_file = NULL;
+
+    if (!strcmp(str_ovconf_fpath, "bt_stack.conf.sqc") ||
+        !strcmp(str_ovconf_fpath, "bt_stack.conf.debug")) {
+
+      if ((strlen(str_ovconf_fpath) + strlen(prefix_fpath1)) <= (MTK_STACK_CONFIG_FPATH_LEN - 1))
+        strcat(prefix_fpath1, str_ovconf_fpath);
+      else {
+        LOG_ERROR("%s M_BTCONF file/path \"prefix+overrideconf_fpath\" exceeds the size of array: %d", __func__, MTK_STACK_CONFIG_FPATH_LEN);
+        return false;
+      }
+
+      test_file = fopen(prefix_fpath1, "rt");
+      if (!test_file) {
+        LOG_INFO("%s M_BTCONF open %s fails!", __func__, prefix_fpath1);
+        return false;
+      } else {
+
+        fclose(test_file);
+        p_fpath = prefix_fpath1;
+      }
+    } else {
+
+      test_file = fopen(str_ovconf_fpath, "rt");
+      if (!test_file) {
+        LOG_INFO("%s M_BTCONF open %s fails!", __func__, str_ovconf_fpath);
+        return false;
+      } else {
+
+        fclose(test_file);
+        p_fpath = str_ovconf_fpath;
+      }
+    }
+  }
+
+  if (p_fpath) {
+    LOG_INFO("%s M_BTCONF config_override file/path \"%s\"", __func__, p_fpath);
+    b_override = config_override(config, p_fpath);
+  } else
+      LOG_INFO("%s M_BTCONF config_override file/path is NULL", __func__);
+
+  return b_override;
+}
+
+#endif
+
+#if MTK_STACK_CONFIG_LOG == TRUE
+uint8_t fwcfg_tx[MTK_STACK_CONFIG_NUM_OF_HEXLIST][MTK_STACK_CONFIG_NUM_OF_HEXITEMS];
+
+static void init_fwlog_cmd_ary(void) {
+  int fi;
+
+  /* Initialize fwcfg_tx[fi][0], device/src/Controller.c will send hci commands depends on the value is not ZERO,
+   * So the max. number of hci commands can be sent is 5 NUM_OF_EXTCMD
+   */
+  for (fi = 0 ; fi < MTK_STACK_CONFIG_NUM_OF_HEXLIST; fi++) {
+    fwcfg_tx[fi][0] = 0;
+  }
+}
+
+static bool parse_fwlog_pairs(config_t *pick_fwlog_conf) {
+  bool b_check_hci_cmd_ready = false;
+
+  if (!pick_fwlog_conf) {
+    LOG_INFO(LOG_TAG, "%s M_BTCONF invalid conf for fwlog key/vals", __func__);
+    return false;
+
+  } else {
+    #define NUM_OF_OCTS_BF_PARAMETER 4
+    #define IDX_OF_PARAMLEN_IN_OCTS 3
+    /* C1 = 01 BE FC 01 05 */
+    /* C2 = 01 5F FC 2A 50 01 09 00 00 00
+              01 00 00 00
+              00 00 00 00
+              01 00 00 00
+              01 00 00 00
+              01 00 00 00
+              01 00 00 00
+              01 00 01 00
+              03 38 00 00
+              01 00 00 00
+
+       param len of C1 = 0x01
+       param len of C2 = 0x2A
+       NUM_OF_OCTS_BF_PARAMETER 4 including len oct
+     */
+
+    unsigned int c1val[MTK_STACK_CONFIG_NUM_OF_HEXITEMS] = {'\0'};
+    unsigned int c2val[MTK_STACK_CONFIG_NUM_OF_HEXITEMS] = {'\0'};
+    const char* C1;
+    const char *C2[MTK_STACK_CONFIG_NUM_OF_HEXROWITEMS] = { "\0" };
+    int hexcidx = 0;
+    char strkey[32] = { '\0' };
+
+    C1 = config_get_string(pick_fwlog_conf, CONFIG_MTK_FWLOG_SECTION, BTLOG_FWLOG_HCI_CMD1, "");
+
+    C2[0] = config_get_string(pick_fwlog_conf, CONFIG_MTK_FWLOG_SECTION, BTLOG_FWLOG_HCI_CMD2, "");
+    for (hexcidx = 1; hexcidx < MTK_STACK_CONFIG_NUM_OF_HEXROWITEMS; hexcidx++) {
+      sprintf(strkey, "%s%02d", BTLOG_FWLOG_HCI_CMD2, hexcidx);
+      LOG_INFO(LOG_TAG, "strkey=%s", strkey);
+      C2[hexcidx] = config_get_string(pick_fwlog_conf, CONFIG_MTK_FWLOG_SECTION, strkey, "");
+    }
+
+    if (*C1) {
+      int j, plen;
+      int ret = sscanf(C1, "%02x %02x %02x %02x %02x %02x %02x %02x %02x %02x %02x %02x %02x %02x %02x %02x",
+                       c1val, c1val+1, c1val+2, c1val+3, c1val+4, c1val+5, c1val+6, c1val+7,
+                       c1val+8, c1val+9, c1val+10, c1val+11, c1val+12, c1val+13, c1val+14, c1val+15);
+      LOG_INFO(LOG_TAG, "M_BTCONF scan %d hex", ret);
+      for (j = 0; j < ret; j++) {
+          LOG_INFO(LOG_TAG, " 0x%x", c1val[j]);
+          fwcfg_tx[0][j] = (uint8_t)c1val[j];
+      }
+
+      plen = fwcfg_tx[0][IDX_OF_PARAMLEN_IN_OCTS];
+      if (ret == (plen + NUM_OF_OCTS_BF_PARAMETER)) {
+        LOG_INFO(LOG_TAG, "M_BTCONF scanned param num matches the value (0x%02x) in command", plen);
+        b_check_hci_cmd_ready = true;
+      } else {
+        LOG_INFO(LOG_TAG, "M_BTCONF scanned param num (0x%02x) doesn't match the value (0x%02x) in command", ret - NUM_OF_OCTS_BF_PARAMETER, plen);
+        b_check_hci_cmd_ready = false;
+      }
+    } else {
+      LOG_INFO(LOG_TAG, "M_BTCONF no \"C1\" section");
+      b_check_hci_cmd_ready = false;
+    }
+
+    if (*C2[0] && b_check_hci_cmd_ready) {
+      int j, plen, ret, cidx = 0, didx = 0;
+
+      while (cidx < MTK_STACK_CONFIG_NUM_OF_HEXROWITEMS && C2[cidx]) {
+        ret = sscanf(C2[cidx], "%02x %02x %02x %02x %02x %02x %02x %02x %02x %02x %02x %02x %02x %02x %02x %02x",
+                     c2val, c2val+1, c2val+2, c2val+3, c2val+4, c2val+5, c2val+6, c2val+7,
+                     c2val+8, c2val+9, c2val+10, c2val+11, c2val+12, c2val+13, c2val+14, c2val+15);
+        LOG_INFO(LOG_TAG, "M_BTCONF scan %d hex", ret);
+        if (ret > 0) {
+          for (j = 0; j < ret; j++) {
+            LOG_INFO(LOG_TAG, " 0x%x", c2val[j]);
+            fwcfg_tx[1][didx] = (uint8_t)c2val[j];
+            didx++;
+          }
+        }
+        cidx++;
+      }
+
+      plen = fwcfg_tx[1][IDX_OF_PARAMLEN_IN_OCTS];
+      LOG_INFO(LOG_TAG, "M_BTCONF plen = 0x%x", fwcfg_tx[1][IDX_OF_PARAMLEN_IN_OCTS]);
+      if (didx == (plen + NUM_OF_OCTS_BF_PARAMETER)) {
+        LOG_INFO(LOG_TAG, "M_BTCONF scanned param num matches the value (0x%02x) in command", plen);
+        b_check_hci_cmd_ready = true;
+      } else {
+        LOG_INFO(LOG_TAG, "M_BTCONF scanned param num (0x%02x) doesn't match the value (0x%02x) in command", didx - NUM_OF_OCTS_BF_PARAMETER, plen);
+        b_check_hci_cmd_ready = false;
+      }
+    } else {
+      if (!*C2[0]) {
+        LOG_INFO(LOG_TAG, "M_BTCONF no \"C2\" section");
+        b_check_hci_cmd_ready = false;
+      }
+    }
+    return b_check_hci_cmd_ready;
+  }
+
+  return false;
+}
+
+static bool get_fwlog_hci_pack_hexlists(void) {
+
+  int ret = false;
+  init_fwlog_cmd_ary();
+  config_t * config = stack_config_get_interface()->get_all();
+  if (config_get_bool(config, CONFIG_DEFAULT_SECTION, BTSNOOP_TURNED_ON_KEY, false)) {
+    LOG_INFO(LOG_TAG, "M_BTCONF attempt to parse fwlog hci cmds");
+    if (false == parse_fwlog_pairs(config)) {
+      /* empty hci commands */
+      LOG_INFO(LOG_TAG, "M_BTCONF empty hci cmds");
+      init_fwlog_cmd_ary();
+    } else
+      ret = true;
+
+  } else {
+    LOG_INFO(LOG_TAG, "%s M_BTCONF %s=false => Don't parse fwlog hci cmds", __func__, BTSNOOP_TURNED_ON_KEY);
+  }
+
+  return ret;
+}
+
+static const uint8_t *get_fwlog_hci_whole_hexlist(void) {
+  return (uint8_t *)fwcfg_tx;
+}
+
+const stack_config_pack_hexlist_t fwlog_hci_hexlist_interface = {
+  get_fwlog_hci_pack_hexlists,
+  get_fwlog_hci_whole_hexlist,
+};
+
+const stack_config_pack_hexlist_t *stack_config_fwlog_hexs_get_interface() {
+  return &fwlog_hci_hexlist_interface;
+}
+
+#endif /* MTK_STACK_CONFIG_LOG == TRUE */
+
diff --git a/audio_a2dp_hw/mediatek/hci/hci_fw_core_dump_ctrl.c b/audio_a2dp_hw/mediatek/hci/hci_fw_core_dump_ctrl.c
new file mode 100644
index 00000000..624addc4
--- /dev/null
+++ b/audio_a2dp_hw/mediatek/hci/hci_fw_core_dump_ctrl.c
@@ -0,0 +1,67 @@
+#define LOG_TAG "hci_fw_core_dump_ctrl"
+
+#include "osi/include/log.h"
+#include "hci_fw_core_dump_ctrl.h"
+
+#if (MTK_SUPPORT_FW_CORE_DUMP == TRUE)
+typedef enum {
+  ERRCODE_CHIP_RESET_IS_DOING = 88,
+  ERRCODE_CHIP_RESET_IS_DONE = 99
+} chiprst_errcode_t;
+
+static volatile bool b_detect_chiprst_in_write = false;
+static bool b_trig_coredump = false;
+static const vendor_t *m_vendor = NULL;
+
+bool is_chip_doing_reset(void) {
+  bool b_in_reset = b_detect_chiprst_in_write || b_trig_coredump;
+  LOG_INFO(LOG_TAG, "%s %d", __func__, b_in_reset);
+  return b_in_reset;
+}
+
+bool handleFirmwareReset(int error_code) {
+  switch(error_code) {
+  case ERRCODE_CHIP_RESET_IS_DOING: {
+    LOG_ERROR(LOG_TAG, "detect bluetooth firmware is doing chip-reset.");
+    if (!b_detect_chiprst_in_write) {
+        b_detect_chiprst_in_write = true;
+    }
+    // sleep 10ms to avoid busy loop
+    usleep(10000);
+    return true;
+  }
+  case ERRCODE_CHIP_RESET_IS_DONE: {
+    LOG_ERROR(LOG_TAG, "%s restarting the bluetooth process.", __func__);
+    usleep(10000);
+    kill(getpid(), SIGKILL);
+    return true;
+  }
+  }
+  return false;
+}
+
+/* When fw coredump is triggered, stack doesn't need to kill bt process because that
+ * "fw coredump" of vendor library includes coredump and whole-chip-reset,
+ * the feature of "MTK_HCITRANS_DETECT_CHIP_RESET" would take care of detecting
+ * the end of whole-chip-reset and then kill bt process
+ */
+bool triggerFirmwareAssert() {
+  LOG_INFO(LOG_TAG, "%s Stack triggers firmware coredump!", __func__);
+  if (m_vendor == NULL) {
+    LOG_INFO(LOG_TAG, "%s Act FW Coredump Fails! Vender not set.", __func__);
+    return false;
+  }
+  int stack_trigger_reason = 31;
+  if (!m_vendor->send_command(VENDOR_SET_FW_ASSERT, &stack_trigger_reason)) {
+    LOG_INFO(LOG_TAG, "%s Act FW Coredump Success!", __func__);
+    b_trig_coredump = true;
+    return true;
+  }
+  LOG_WARN(LOG_TAG, "%s Act FW Coredump Fails!", __func__);
+  return false;
+}
+
+void setFimrwareCoreDumpVendor(const vendor_t * vendor) {
+  m_vendor = vendor;
+}
+#endif
diff --git a/audio_a2dp_hw/mediatek/hci/twrite.c b/audio_a2dp_hw/mediatek/hci/twrite.c
new file mode 100644
index 00000000..025311e3
--- /dev/null
+++ b/audio_a2dp_hw/mediatek/hci/twrite.c
@@ -0,0 +1,536 @@
+#define LOG_TAG "TWRITE"
+
+#include <stdlib.h>
+#include <stdio.h>
+#include <string.h>
+#include <pthread.h>
+#include <errno.h>
+#include <unistd.h>
+#include <signal.h>
+#include <sys/stat.h>
+#include <sys/time.h>
+#include <sys/prctl.h>
+#include <stdbool.h>
+#include <cutils/properties.h>
+
+#include <arpa/inet.h>
+#include <fcntl.h>
+#include <inttypes.h>
+
+#include "osi/include/osi.h"
+#include "osi/include/log.h"
+#include "stack_config.h"
+
+#include "mdroid_buildcfg.h"
+#include "twrite.h"
+
+#define DBG_LOG_ENABLE FALSE
+
+#if DBG_LOG_ENABLE == TRUE
+#define DBG_LOG_TAG "debug_"LOG_TAG
+#define DBG_LOG(tag, fmt, args...)    LOG_DEBUG(DBG_LOG_TAG, fmt, ##args)
+#else
+#define DBG_LOG(tag, fmt, args...)    ((void)0)
+#endif
+
+#define MAX_NODE_SIZE 1024
+
+#define MAX_LOG_FILE_SIZE   300000000 // max log file size in log alone mode
+#define TRIMMED_PACKET_SIZE   50
+#define DUMMY_PACKET_SIZE   31
+
+#define PROP_SNOOP_LOG_POS "persist.service.bdroid.loglen"
+
+#define BTSNOOP_HEADER "btsnoop\0\0\0\0\1\0\0\x3\xea"
+
+#define BTSNOOP_HEADER_SIZE 16
+
+#define RW(pointer, member) ((*pointer)->member)
+
+enum {
+    B_NORMAL,
+    B_END,      // buffer didn't user, pop after all data write into fd
+    B_SEEK,     // buffer should be seek before pop
+};
+
+typedef struct _BUFFER_NODE {
+    struct _BUFFER_NODE *next;
+    unsigned char buffer[MAX_NODE_SIZE];
+    volatile unsigned char *start, *end;
+    volatile int state;
+    volatile long seek_offset;
+    volatile int seek_origin;
+} BUFFER_NODE;
+
+typedef struct _BUFFER_Q {
+    volatile BUFFER_NODE *bufferQHead;
+    volatile BUFFER_NODE *bufferQTail;
+} BUFFER_Q;
+
+typedef struct _TWRITE_FD {
+    int fd;
+    int writeThreadRun;
+    int error;
+    BUFFER_Q bufferQ;
+
+    pthread_t writeThread;
+    pthread_cond_t writeCond;
+    pthread_mutex_t mtx;
+} TWRITE_FD;
+
+static void initNode(volatile BUFFER_NODE *node);
+static void initQ(BUFFER_Q *bufferQ);
+static void deinitQ(BUFFER_Q *bufferQ);
+// incress buffer size, should only use when buffer fill
+static void pushQ(BUFFER_Q *bufferQ);
+// free empyt buffer node
+static void popQ(BUFFER_Q *bufferQ);
+static void *writeThread();
+
+static int q_cnt = 0;
+
+static TWRITE_FD *twrite_fd = NULL;
+
+BTSNOOP_LOG_MODE m_log_mode = BTSNOOP_LOG_MODE_DEFAULT;
+int btsnoop_logging_pos = 0;
+
+static bool validateLogPath(const char *log_path) {
+  char log_dir[MTK_STACK_CONFIG_FPATH_LEN];
+  char tmp[MTK_STACK_CONFIG_FPATH_LEN];
+  int path_len = strlen(log_path);
+
+  LOG_INFO(LOG_TAG, "%s M_BTCONF log_path: %s", __func__, log_path);
+  if (0 < path_len && path_len < MTK_STACK_CONFIG_FPATH_LEN) {
+    int i = 0;
+    strcpy(log_dir, log_path);
+    while (log_dir[i]) {
+      tmp[i] = log_dir[i];
+      if (log_dir[i] == '/' && i) {
+        tmp[i] = '\0';
+        LOG_INFO(LOG_TAG, "%s tmp: %s", __func__, tmp);
+        if (access(tmp, F_OK) != 0) {
+          if (mkdir(tmp, 0770) == -1) {
+            LOG_ERROR(LOG_TAG, "mkdir error! %s", (char*)strerror(errno));
+            break;
+          }
+        }
+        tmp[i] = '/';
+      }
+      i++;
+    }
+  } else {
+    LOG_ERROR(LOG_TAG, "%s M_BTCONF log_path is longer then 1024", __func__);
+    return false;
+  }
+  return true;
+}
+
+static uint64_t readability_timestamp(void)
+{
+    const int buf_size = 24;
+    char buffer[buf_size];
+    char buffer2[buf_size];
+    struct timeval tv;
+    time_t curtime = time(NULL);
+    struct tm * ltime = localtime(&curtime);
+    strftime(buffer, sizeof(buffer), "%Y%m%d%H%M%S", ltime);
+
+    gettimeofday(&tv, NULL);
+    snprintf(buffer2, sizeof(buffer2), "%s%ld", buffer, tv.tv_usec / 1000);
+
+    return strtoull(buffer2, NULL, 10);
+}
+
+int twrite_lseek(long offset, int origin)
+{
+    volatile BUFFER_NODE **bQTail = &twrite_fd->bufferQ.bufferQTail;
+
+    LOG_INFO(LOG_TAG, "%s", __func__);
+    RW(bQTail, state) = B_SEEK;
+    RW(bQTail, seek_offset) = offset;
+    RW(bQTail, seek_origin) = origin;
+    pushQ(&twrite_fd->bufferQ);
+
+    return 0;
+}
+
+bool twrite_init(const char * log_path, BTSNOOP_LOG_MODE log_mode, int * fd)
+{
+    int logfile_fd = INVALID_FD;
+    char log_path_local[PATH_MAX] = {0};
+    int log_file_mode = O_WRONLY | O_CREAT | O_TRUNC;
+    int log_file_access = S_IRUSR | S_IWUSR | S_IRGRP | S_IWGRP | S_IROTH;
+    *fd = INVALID_FD;
+    if (!validateLogPath(log_path)) {
+        return false;
+    }
+
+    if (stack_config_get_interface()->get_btsnoop_should_save_last()) {
+        char last_log_path[PATH_MAX];
+        snprintf(last_log_path, PATH_MAX, "%s.%" PRIu64, log_path, readability_timestamp());
+        if (!rename(log_path, last_log_path) && errno != ENOENT) {
+            LOG_ERROR(LOG_TAG, "%s unable to rename '%s' to '%s': %s", __func__,
+                log_path, last_log_path, strerror(errno));
+        }
+    }
+
+    twrite_fd = (TWRITE_FD *)malloc(sizeof(TWRITE_FD));
+    if (NULL == twrite_fd) {
+        LOG_ERROR(LOG_TAG, "%s cannot malloc twrite_fd errno = %d (%s)",
+                __func__, errno, strerror(errno));
+        goto ERROR;
+    }
+
+    m_log_mode = log_mode;
+
+    strncpy(log_path_local, log_path, PATH_MAX);
+    if (m_log_mode == BTSNOOP_LOG_MODE_ALONE) {
+        char logging_pos_prop[PROPERTY_VALUE_MAX] = {0};
+        // Modify Log Path and file open flag
+        strncat(log_path_local, "_MTK", PATH_MAX);
+        log_file_mode = O_WRONLY | O_CREAT;
+        if(access(log_path_local, F_OK) != 0) {
+            btsnoop_logging_pos = 0;
+            sprintf(logging_pos_prop, "%d", btsnoop_logging_pos);
+            property_set(PROP_SNOOP_LOG_POS, logging_pos_prop);
+        } else {
+            property_get(PROP_SNOOP_LOG_POS, logging_pos_prop, "0");
+            btsnoop_logging_pos = atoi(logging_pos_prop);
+        }
+        LOG_INFO(LOG_TAG, "[BT] M_BTCONF log fetch file len: %d", btsnoop_logging_pos);
+    }
+    logfile_fd = open(log_path_local, log_file_mode, log_file_access);
+    if (logfile_fd == INVALID_FD) {
+      LOG_ERROR(LOG_TAG, "%s unable to open '%s': %s", __func__, log_path_local, strerror(errno));
+      goto ERROR;
+    }
+
+    initQ(&twrite_fd->bufferQ);
+    twrite_fd->fd = logfile_fd;
+    twrite_fd->writeThreadRun = 1;
+    twrite_fd->error = 0;
+    pthread_mutex_init(&twrite_fd->mtx, NULL);
+    pthread_cond_init(&twrite_fd->writeCond, NULL);
+    pthread_mutex_lock(&twrite_fd->mtx);
+
+    if (0 != pthread_create(&twrite_fd->writeThread, NULL, writeThread,
+                (void*)twrite_fd)) {
+        LOG_ERROR(LOG_TAG, "create write thread failed");
+        goto ERROR;
+    }
+
+    pthread_mutex_lock(&twrite_fd->mtx);
+    pthread_mutex_unlock(&twrite_fd->mtx);
+
+    // M: Write header
+    int nWritten = write(logfile_fd, BTSNOOP_HEADER, BTSNOOP_HEADER_SIZE);
+    if (nWritten != BTSNOOP_HEADER_SIZE) {
+      LOG_INFO(LOG_TAG, "write btsnoop header failed : nWritten=%d", nWritten);
+      if (nWritten < 0)
+        LOG_ERROR(LOG_TAG, "write btsnoop header failed: err=%s, errno=%d", strerror(errno), errno);
+      twrite_deinit();
+      goto ERROR;
+    }
+
+    if (m_log_mode == BTSNOOP_LOG_MODE_ALONE) {
+      if (btsnoop_logging_pos == 0)
+        btsnoop_logging_pos += BTSNOOP_HEADER_SIZE;
+      else
+        twrite_lseek(btsnoop_logging_pos, SEEK_SET);
+    }
+    *fd = logfile_fd;
+    return true;
+ERROR:
+    if (twrite_fd != NULL) {
+      free(twrite_fd);
+      twrite_fd = NULL;
+    }
+    if (logfile_fd != INVALID_FD) {
+      close(logfile_fd);
+      logfile_fd = INVALID_FD;
+    }
+    LOG_ERROR(LOG_TAG, "There is no hci log in this run!");
+    return false;
+}
+
+int twrite_deinit()
+{
+    if (NULL == twrite_fd) {
+        LOG_ERROR(LOG_TAG, "deinit with NULL fd");
+        return -1;
+    }
+    if (0 == twrite_fd->writeThreadRun) { // if deinit twice ignore
+        LOG_ERROR(LOG_TAG, "sniffer thread already end");
+        return -2;
+    }
+    twrite_fd->writeThreadRun = 0;
+    if (pthread_cond_signal(&twrite_fd->writeCond)) {
+        LOG_ERROR(LOG_TAG, "deinit pthread_cond_signal failed");
+    }
+    pthread_join(twrite_fd->writeThread, NULL);
+    deinitQ(&twrite_fd->bufferQ);
+
+    free(twrite_fd);
+    twrite_fd = NULL;
+
+    if (m_log_mode == BTSNOOP_LOG_MODE_ALONE) {
+        char logging_pos_prop[PROPERTY_VALUE_MAX] = {0};
+        sprintf(logging_pos_prop, "%d", btsnoop_logging_pos);
+        property_set(PROP_SNOOP_LOG_POS, logging_pos_prop);
+        LOG_INFO(LOG_TAG, "%s logging pos is: %s", __func__, logging_pos_prop);
+    }
+
+    LOG_DEBUG(LOG_TAG, "%s: done", __func__);
+    return 0;
+}
+
+int twrite_write(const unsigned char *data, int len)
+{
+    const unsigned char *p, *e;
+    volatile unsigned char *bufferEnd;
+    volatile unsigned char *QTailEnd;
+    volatile BUFFER_NODE **bQTail = &twrite_fd->bufferQ.bufferQTail;
+    //LOG_DEBUG(LOG_TAG, "data len = %d", len);
+    if (twrite_fd == NULL || twrite_fd->fd < 0) {
+      return -1;
+    }
+    if (twrite_fd->error) {
+        LOG_ERROR(LOG_TAG, "write thread have error, ignore err=%s, errno=%d",
+                strerror(twrite_fd->error), twrite_fd->error);
+        return -1;
+    }
+    p = data;
+    e = data + len;
+    if (NULL == *bQTail) {
+        pushQ(&twrite_fd->bufferQ);
+    }
+    // log longer than left buffer size
+    while (RW(bQTail, buffer) + MAX_NODE_SIZE - RW(bQTail, end) < (e - p)) {
+        bufferEnd = RW(bQTail, buffer) + MAX_NODE_SIZE;
+        QTailEnd = RW(bQTail, end);
+        while (QTailEnd != bufferEnd) { // memcpy
+            *(QTailEnd++) = *(p++);
+        }
+        RW(bQTail, end) = QTailEnd;
+        pushQ(&twrite_fd->bufferQ);
+    }
+    QTailEnd = RW(bQTail, end);
+    while (e != p) { // memcpy
+        *(QTailEnd++) = *(p++);
+    }
+    RW(bQTail, end) = QTailEnd;
+    if (pthread_cond_signal(&twrite_fd->writeCond)) {
+        LOG_ERROR(LOG_TAG, "%s: pthread_cond_signal failed", __func__);
+        return -1;
+    }
+    return len;
+}
+
+void twrite_write_packet(SNOOP_WRITE btsnoop_write, int type,
+    const uint8_t *packet, int length_he_in, int length_in, int flags_in,
+    int drops_in, uint32_t time_hi_in, uint32_t time_lo_in) {
+  //refer to definition in btsnoop_net.c
+  const int kAclPacket = 2;
+  const int kEventPacket = 4;
+  uint8_t acc_header[32] = {'\0'};
+  uint8_t dummy_data[90] = {'\0'};
+  uint32_t drops_MTK = 0xFEEDF00D ;
+  int length_he;
+  int length;
+  int flags;
+  int drops;
+  uint32_t time_hi;
+  uint32_t time_lo;
+  if (m_log_mode == BTSNOOP_LOG_MODE_ALONE)
+    drops = htonl(drops_MTK);
+  else
+    drops = htonl(drops_in);
+
+  time_hi = htonl(time_hi_in);
+  time_lo = htonl(time_lo_in);
+
+  length_he = htonl(length_he_in);
+  if(m_log_mode == BTSNOOP_LOG_MODE_ALONE) {
+    if(length_he_in > TRIMMED_PACKET_SIZE && type == kAclPacket)
+          length_in = TRIMMED_PACKET_SIZE;
+    // Write a dummy packet to full fill the last content of file.
+    if(btsnoop_logging_pos + length_in + 24 > MAX_LOG_FILE_SIZE - DUMMY_PACKET_SIZE) {
+        uint8_t acc_header[32] = {'\0'};
+        int flags_dummy, type_dummy, length_dummy;
+        flags_dummy = htonl(3);
+        type_dummy = kEventPacket;
+        length_dummy = MAX_LOG_FILE_SIZE - btsnoop_logging_pos;
+        length_dummy = htonl(length_dummy);
+        dummy_data[0] = 0xff;
+        dummy_data[1] = 0xf1;
+        memcpy(acc_header, &length_dummy, 4);
+        memcpy(acc_header+4, &length_dummy, 4);
+        memcpy(acc_header+8, &flags_dummy, 4);
+        memcpy(acc_header+12, &drops, 4);
+        memcpy(acc_header+16, &time_hi, 4);
+        memcpy(acc_header+20, &time_lo, 4);
+        memcpy(acc_header+24, &type_dummy, 1);
+        length_dummy = ntohl(length_dummy);
+        btsnoop_write(acc_header, 25);
+        btsnoop_write(dummy_data, length_dummy - 1);
+        twrite_lseek(BTSNOOP_HEADER_SIZE, SEEK_SET);
+        LOG_INFO(LOG_TAG, "[BT] M_BTCONF should_log_MTK twrite_lseek: %d", btsnoop_logging_pos);
+        btsnoop_logging_pos = BTSNOOP_HEADER_SIZE;
+    }
+    btsnoop_logging_pos += (length_in + 24);
+  }
+  length = htonl(length_in);
+  flags = htonl(flags_in);
+  memcpy(acc_header, &length_he, 4);
+  memcpy(acc_header+4, &length, 4);
+  memcpy(acc_header+8, &flags, 4);
+  memcpy(acc_header+12, &drops, 4);
+  memcpy(acc_header+16, &time_hi, 4);
+  memcpy(acc_header+20, &time_lo, 4);
+  memcpy(acc_header+24, &type, 1);
+  btsnoop_write(acc_header, 25);
+  btsnoop_write(packet, length_in - 1);
+}
+
+static void initQ(BUFFER_Q *bufferQ)
+{
+    bufferQ->bufferQHead = malloc(sizeof(BUFFER_NODE));
+    bufferQ->bufferQTail = bufferQ->bufferQHead;
+    initNode(bufferQ->bufferQHead);
+    return;
+}
+
+static void deinitQ(BUFFER_Q* bufferQ)
+{
+    while(bufferQ->bufferQHead->next) {
+        popQ(bufferQ);
+    }
+    free((void*)bufferQ->bufferQHead);
+    return;
+}
+
+static void initNode(volatile BUFFER_NODE *node)
+{
+    node->next = NULL;
+    node->start = node->buffer;
+    node->end = node->buffer;
+    node->state = B_NORMAL;
+    node->seek_offset = 0;
+    node->seek_origin = SEEK_CUR;
+}
+
+static void popQ(BUFFER_Q *bufferQ)
+{
+    volatile BUFFER_NODE *tmp;
+    volatile BUFFER_NODE **bQHead = &bufferQ->bufferQHead;
+    if (NULL == *bQHead || NULL == RW(bQHead, next) ||
+            RW(bQHead, end) > RW(bQHead, start) ||
+            RW(bQHead, state) == B_SEEK) {
+        // keep one node in queue, and check if all buffer was wrote
+        return;
+    } else {
+        tmp = *bQHead;
+    }
+
+    *bQHead = RW(bQHead, next);
+
+    free((void*)tmp);
+    q_cnt--;
+    return;
+}
+
+static void pushQ(BUFFER_Q *bufferQ)
+{
+    volatile BUFFER_NODE **bQHead = &bufferQ->bufferQHead;
+    volatile BUFFER_NODE **bQTail = &bufferQ->bufferQTail;
+    BUFFER_NODE *node;
+    node = malloc(sizeof(BUFFER_NODE));
+    initNode(node);
+    q_cnt++;
+
+    if (NULL == *bQHead && NULL == *bQTail) {
+        *bQHead = node;
+        *bQTail = node;
+    } else {
+        RW(bQTail, next) = node;
+        *bQTail = node;
+    }
+    return;
+}
+
+static void *writeThread(void *t_fd)
+{
+    TWRITE_FD *twrite_fd = (TWRITE_FD *)t_fd;
+    volatile BUFFER_NODE **bQHead = &twrite_fd->bufferQ.bufferQHead;
+    BUFFER_Q *bufferQ = &twrite_fd->bufferQ;
+    int nWritten;
+    int bytesToWrite;
+
+    if (prctl(PR_SET_NAME, (unsigned long)"twrite_logout", 0, 0, 0) == -1) {
+      LOG_DEBUG(LOG_TAG, "%s unable to set thread name: %s", __func__, strerror(errno));
+    }
+
+    LOG_DEBUG(LOG_TAG, "write Thread start");
+#ifdef TWRITE_TEST
+    srand(time(NULL));
+#endif
+    do {
+        pthread_cond_wait(&twrite_fd->writeCond, &twrite_fd->mtx);
+        DBG_LOG(LOG_TAG, "g Cond: q_cnt(%d)", q_cnt);
+        popQ(bufferQ); // try to remove empty Node
+        while (RW(bQHead, start) != RW(bQHead, end) ||
+                RW(bQHead, state) == B_SEEK) {
+#ifdef TWRITE_TEST
+            usleep(rand() % 1000000);
+#endif
+            nWritten = 0;
+            bytesToWrite = RW(bQHead, end) - RW(bQHead, start);
+
+            while (bytesToWrite > 0) {
+                nWritten = write(twrite_fd->fd, (void*)RW(bQHead, start),
+                        bytesToWrite);
+                if (nWritten < 0) {
+                    twrite_fd->error = errno;
+                    LOG_ERROR(LOG_TAG, "write failed : nWritten=%d, err=%s, errno=%d",
+                            nWritten, strerror(errno), errno);
+                    return NULL;
+                }
+                DBG_LOG(LOG_TAG, "%db wr fd=%d", nWritten, twrite_fd->fd);
+                bytesToWrite -= nWritten;
+                RW(bQHead, start) += nWritten;
+            }
+            if(RW(bQHead, state) == B_SEEK &&
+                    RW(bQHead, start) == RW(bQHead, end)) {// process seek buffer
+                off_t ret;
+                RW(bQHead, state) = B_END;
+                DBG_LOG(LOG_TAG, "do lseek");
+                ret = lseek(twrite_fd->fd, RW(bQHead, seek_offset), RW(bQHead, seek_origin));
+                if (ret < 0) {
+                  LOG_ERROR(LOG_TAG, "lseek error: %s", strerror(errno));
+                }
+                popQ(bufferQ);
+            }
+            else if (RW(bQHead, start) == RW(bQHead, buffer) + MAX_NODE_SIZE) {
+                popQ(bufferQ);
+            }
+        }
+    } while (twrite_fd->writeThreadRun);
+
+    LOG_DEBUG(LOG_TAG, "exit loop of writeThread");
+    return NULL;
+}
+
+/**
+ * Check system property to decide whether override mode is used.
+ * TODO: use stack config file to control log mode uniformly.
+ */
+bool enable_mtk_btsnoop() {
+  bool ret = false;
+#if MTK_BTSNOOPLOG_MODE_SUPPRT == TRUE
+  char should_log_MTK_prop[PROPERTY_VALUE_MAX] = {0};
+  property_get("bt.hcilogalone", should_log_MTK_prop, "0" );
+  LOG_INFO(LOG_TAG, "[BT] M_BTCONF should_log : %s", should_log_MTK_prop);
+  ret = atoi(should_log_MTK_prop) ? true : false;
+#endif
+  return ret;
+}
diff --git a/audio_a2dp_hw/mediatek/include/btif_config_mtk_util.h b/audio_a2dp_hw/mediatek/include/btif_config_mtk_util.h
new file mode 100644
index 00000000..aa08cd83
--- /dev/null
+++ b/audio_a2dp_hw/mediatek/include/btif_config_mtk_util.h
@@ -0,0 +1,75 @@
+/* Copyright Statement:
+ *
+ * This software/firmware and related documentation ("MediaTek Software") are
+ * protected under relevant copyright laws. The information contained herein
+ * is confidential and proprietary to MediaTek Inc. and/or its licensors.
+ * Without the prior written permission of MediaTek inc. and/or its licensors,
+ * any reproduction, modification, use or disclosure of MediaTek Software,
+ * and information contained herein, in whole or in part, shall be strictly prohibited.
+ *
+ * MediaTek Inc. (C) 2015. All rights reserved.
+ *
+ * BY OPENING THIS FILE, RECEIVER HEREBY UNEQUIVOCALLY ACKNOWLEDGES AND AGREES
+ * THAT THE SOFTWARE/FIRMWARE AND ITS DOCUMENTATIONS ("MEDIATEK SOFTWARE")
+ * RECEIVED FROM MEDIATEK AND/OR ITS REPRESENTATIVES ARE PROVIDED TO RECEIVER ON
+ * AN "AS-IS" BASIS ONLY. MEDIATEK EXPRESSLY DISCLAIMS ANY AND ALL WARRANTIES,
+ * EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE IMPLIED WARRANTIES OF
+ * MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE OR NONINFRINGEMENT.
+ * NEITHER DOES MEDIATEK PROVIDE ANY WARRANTY WHATSOEVER WITH RESPECT TO THE
+ * SOFTWARE OF ANY THIRD PARTY WHICH MAY BE USED BY, INCORPORATED IN, OR
+ * SUPPLIED WITH THE MEDIATEK SOFTWARE, AND RECEIVER AGREES TO LOOK ONLY TO SUCH
+ * THIRD PARTY FOR ANY WARRANTY CLAIM RELATING THERETO. RECEIVER EXPRESSLY ACKNOWLEDGES
+ * THAT IT IS RECEIVER'S SOLE RESPONSIBILITY TO OBTAIN FROM ANY THIRD PARTY ALL PROPER LICENSES
+ * CONTAINED IN MEDIATEK SOFTWARE. MEDIATEK SHALL ALSO NOT BE RESPONSIBLE FOR ANY MEDIATEK
+ * SOFTWARE RELEASES MADE TO RECEIVER'S SPECIFICATION OR TO CONFORM TO A PARTICULAR
+ * STANDARD OR OPEN FORUM. RECEIVER'S SOLE AND EXCLUSIVE REMEDY AND MEDIATEK'S ENTIRE AND
+ * CUMULATIVE LIABILITY WITH RESPECT TO THE MEDIATEK SOFTWARE RELEASED HEREUNDER WILL BE,
+ * AT MEDIATEK'S OPTION, TO REVISE OR REPLACE THE MEDIATEK SOFTWARE AT ISSUE,
+ * OR REFUND ANY SOFTWARE LICENSE FEES OR SERVICE CHARGE PAID BY RECEIVER TO
+ * MEDIATEK FOR SUCH MEDIATEK SOFTWARE AT ISSUE.
+ *
+ * The following software/firmware and/or related documentation ("MediaTek Software")
+ * have been modified by MediaTek Inc. All revisions are subject to any receiver's
+ * applicable license agreements with MediaTek Inc.
+ */
+
+/*****************************************************************************
+*  Copyright Statement:
+*  --------------------
+*  This software is protected by Copyright and the information contained
+*  herein is confidential. The software may not be copied and the information
+*  contained herein may not be used or disclosed except with the written
+*  permission of MediaTek Inc. (C) 2005
+*
+*  BY OPENING THIS FILE, BUYER HEREBY UNEQUIVOCALLY ACKNOWLEDGES AND AGREES
+*  THAT THE SOFTWARE/FIRMWARE AND ITS DOCUMENTATIONS ("MEDIATEK SOFTWARE")
+*  RECEIVED FROM MEDIATEK AND/OR ITS REPRESENTATIVES ARE PROVIDED TO BUYER ON
+*  AN "AS-IS" BASIS ONLY. MEDIATEK EXPRESSLY DISCLAIMS ANY AND ALL WARRANTIES,
+*  EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE IMPLIED WARRANTIES OF
+*  MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE OR NONINFRINGEMENT.
+*  NEITHER DOES MEDIATEK PROVIDE ANY WARRANTY WHATSOEVER WITH RESPECT TO THE
+*  SOFTWARE OF ANY THIRD PARTY WHICH MAY BE USED BY, INCORPORATED IN, OR
+*  SUPPLIED WITH THE MEDIATEK SOFTWARE, AND BUYER AGREES TO LOOK ONLY TO SUCH
+*  THIRD PARTY FOR ANY WARRANTY CLAIM RELATING THERETO. MEDIATEK SHALL ALSO
+*  NOT BE RESPONSIBLE FOR ANY MEDIATEK SOFTWARE RELEASES MADE TO BUYER'S
+*  SPECIFICATION OR TO CONFORM TO A PARTICULAR STANDARD OR OPEN FORUM.
+*
+*  BUYER'S SOLE AND EXCLUSIVE REMEDY AND MEDIATEK'S ENTIRE AND CUMULATIVE
+*  LIABILITY WITH RESPECT TO THE MEDIATEK SOFTWARE RELEASED HEREUNDER WILL BE,
+*  AT MEDIATEK'S OPTION, TO REVISE OR REPLACE THE MEDIATEK SOFTWARE AT ISSUE,
+*  OR REFUND ANY SOFTWARE LICENSE FEES OR SERVICE CHARGE PAID BY BUYER TO
+*  MEDIATEK FOR SUCH MEDIATEK SOFTWARE AT ISSUE.
+*
+*  THE TRANSACTION CONTEMPLATED HEREUNDER SHALL BE CONSTRUED IN ACCORDANCE
+*  WITH THE LAWS OF THE STATE OF CALIFORNIA, USA, EXCLUDING ITS CONFLICT OF
+*  LAWS PRINCIPLES.  ANY DISPUTES, CONTROVERSIES OR CLAIMS ARISING THEREOF AND
+*  RELATED THERETO SHALL BE SETTLED BY ARBITRATION IN SAN FRANCISCO, CA, UNDER
+*  THE RULES OF THE INTERNATIONAL CHAMBER OF COMMERCE (ICC).
+*
+*****************************************************************************/
+#pragma once
+
+/*******************************************************************************
+**  Functions
+********************************************************************************/
+config_t *load_blueangel_cfg(void);
diff --git a/audio_a2dp_hw/mediatek/include/hci_fw_core_dump_ctrl.h b/audio_a2dp_hw/mediatek/include/hci_fw_core_dump_ctrl.h
new file mode 100644
index 00000000..c078cd78
--- /dev/null
+++ b/audio_a2dp_hw/mediatek/include/hci_fw_core_dump_ctrl.h
@@ -0,0 +1,15 @@
+#pragma once
+#include "hci/include/vendor.h"
+#include "mdroid_buildcfg.h"
+
+#if (MTK_SUPPORT_FW_CORE_DUMP == TRUE)
+
+bool is_chip_doing_reset();
+
+bool handleFirmwareReset(int error_code);
+
+bool triggerFirmwareAssert();
+
+void setFimrwareCoreDumpVendor(const vendor_t * vendor);
+
+#endif
diff --git a/audio_a2dp_hw/mediatek/include/interop_mtk.h b/audio_a2dp_hw/mediatek/include/interop_mtk.h
new file mode 100644
index 00000000..5d54187e
--- /dev/null
+++ b/audio_a2dp_hw/mediatek/include/interop_mtk.h
@@ -0,0 +1,71 @@
+/* Copyright Statement:
+ * *
+ * * This software/firmware and related documentation ("MediaTek Software") are
+ * * protected under relevant copyright laws. The information contained herein
+ * * is confidential and proprietary to MediaTek Inc. and/or its licensors.
+ * * Without the prior written permission of MediaTek inc. and/or its licensors,
+ * * any reproduction, modification, use or disclosure of MediaTek Software,
+ * * and information contained herein, in whole or in part, shall be strictly prohibited.
+ * *
+ * * MediaTek Inc. (C) 2010. All rights reserved.
+ * *
+ * * BY OPENING THIS FILE, RECEIVER HEREBY UNEQUIVOCALLY ACKNOWLEDGES AND AGREES
+ * * THAT THE SOFTWARE/FIRMWARE AND ITS DOCUMENTATIONS ("MEDIATEK SOFTWARE")
+ * * RECEIVED FROM MEDIATEK AND/OR ITS REPRESENTATIVES ARE PROVIDED TO RECEIVER ON
+ * * AN "AS-IS" BASIS ONLY. MEDIATEK EXPRESSLY DISCLAIMS ANY AND ALL WARRANTIES,
+ * * EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE IMPLIED WARRANTIES OF
+ * * MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE OR NONINFRINGEMENT.
+ * * NEITHER DOES MEDIATEK PROVIDE ANY WARRANTY WHATSOEVER WITH RESPECT TO THE
+ * * SOFTWARE OF ANY THIRD PARTY WHICH MAY BE USED BY, INCORPORATED IN, OR
+ * * SUPPLIED WITH THE MEDIATEK SOFTWARE, AND RECEIVER AGREES TO LOOK ONLY TO SUCH
+ * * THIRD PARTY FOR ANY WARRANTY CLAIM RELATING THERETO. RECEIVER EXPRESSLY ACKNOWLEDGES
+ * * THAT IT IS RECEIVER'S SOLE RESPONSIBILITY TO OBTAIN FROM ANY THIRD PARTY ALL PROPER LICENSES
+ * * CONTAINED IN MEDIATEK SOFTWARE. MEDIATEK SHALL ALSO NOT BE RESPONSIBLE FOR ANY MEDIATEK
+ * * SOFTWARE RELEASES MADE TO RECEIVER'S SPECIFICATION OR TO CONFORM TO A PARTICULAR
+ * * STANDARD OR OPEN FORUM. RECEIVER'S SOLE AND EXCLUSIVE REMEDY AND MEDIATEK'S ENTIRE AND
+ * * CUMULATIVE LIABILITY WITH RESPECT TO THE MEDIATEK SOFTWARE RELEASED HEREUNDER WILL BE,
+ * * AT MEDIATEK'S OPTION, TO REVISE OR REPLACE THE MEDIATEK SOFTWARE AT ISSUE,
+ * * OR REFUND ANY SOFTWARE LICENSE FEES OR SERVICE CHARGE PAID BY RECEIVER TO
+ * * MEDIATEK FOR SUCH MEDIATEK SOFTWARE AT ISSUE.
+ * *
+ * * The following software/firmware and/or related documentation ("MediaTek Software")
+ * * have been modified by MediaTek Inc. All revisions are subject to any receiver's
+ * * applicable license agreements with MediaTek Inc.
+ * */
+
+
+/******************************************************************************
+ *
+ *  This file contains functions for the MTK defined interop function
+ *
+ ******************************************************************************/
+#pragma once
+
+#if MTK_STACK_CONFIG_BL == TRUE
+#include "device/include/interop.h"
+
+/*******************************************************************************
+**
+** Function         interop_mtk_match_name
+**
+** Description      Looks up the interop_name_database for the
+**                  specified BD address.
+**
+** Returns          TRUE if matched, else FALSE
+**
+*******************************************************************************/
+extern bool interop_mtk_match_name(const interop_feature_t feature, const bt_bdaddr_t* addr);
+
+
+/*******************************************************************************
+**
+** Function         interop_mtk_match_addr_name
+**
+** Description      Looks up the interop_addr_database and interop_name_database for the
+**                  specified BD address.
+**
+** Returns          TRUE if matched, else FALSE
+**
+*******************************************************************************/
+extern bool interop_mtk_match_addr_name(const interop_feature_t feature, const bt_bdaddr_t* addr);
+#endif
diff --git a/audio_a2dp_hw/mediatek/include/mdroid_buildcfg.h b/audio_a2dp_hw/mediatek/include/mdroid_buildcfg.h
new file mode 100644
index 00000000..b7f4a413
--- /dev/null
+++ b/audio_a2dp_hw/mediatek/include/mdroid_buildcfg.h
@@ -0,0 +1,432 @@
+/* Copyright Statement:
+ * *
+ * * This software/firmware and related documentation ("MediaTek Software") are
+ * * protected under relevant copyright laws. The information contained herein
+ * * is confidential and proprietary to MediaTek Inc. and/or its licensors.
+ * * Without the prior written permission of MediaTek inc. and/or its licensors,
+ * * any reproduction, modification, use or disclosure of MediaTek Software,
+ * * and information contained herein, in whole or in part, shall be strictly prohibited.
+ * *
+ * * MediaTek Inc. (C) 2010. All rights reserved.
+ * *
+ * * BY OPENING THIS FILE, RECEIVER HEREBY UNEQUIVOCALLY ACKNOWLEDGES AND AGREES
+ * * THAT THE SOFTWARE/FIRMWARE AND ITS DOCUMENTATIONS ("MEDIATEK SOFTWARE")
+ * * RECEIVED FROM MEDIATEK AND/OR ITS REPRESENTATIVES ARE PROVIDED TO RECEIVER ON
+ * * AN "AS-IS" BASIS ONLY. MEDIATEK EXPRESSLY DISCLAIMS ANY AND ALL WARRANTIES,
+ * * EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE IMPLIED WARRANTIES OF
+ * * MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE OR NONINFRINGEMENT.
+ * * NEITHER DOES MEDIATEK PROVIDE ANY WARRANTY WHATSOEVER WITH RESPECT TO THE
+ * * SOFTWARE OF ANY THIRD PARTY WHICH MAY BE USED BY, INCORPORATED IN, OR
+ * * SUPPLIED WITH THE MEDIATEK SOFTWARE, AND RECEIVER AGREES TO LOOK ONLY TO SUCH
+ * * THIRD PARTY FOR ANY WARRANTY CLAIM RELATING THERETO. RECEIVER EXPRESSLY ACKNOWLEDGES
+ * * THAT IT IS RECEIVER'S SOLE RESPONSIBILITY TO OBTAIN FROM ANY THIRD PARTY ALL PROPER LICENSES
+ * * CONTAINED IN MEDIATEK SOFTWARE. MEDIATEK SHALL ALSO NOT BE RESPONSIBLE FOR ANY MEDIATEK
+ * * SOFTWARE RELEASES MADE TO RECEIVER'S SPECIFICATION OR TO CONFORM TO A PARTICULAR
+ * * STANDARD OR OPEN FORUM. RECEIVER'S SOLE AND EXCLUSIVE REMEDY AND MEDIATEK'S ENTIRE AND
+ * * CUMULATIVE LIABILITY WITH RESPECT TO THE MEDIATEK SOFTWARE RELEASED HEREUNDER WILL BE,
+ * * AT MEDIATEK'S OPTION, TO REVISE OR REPLACE THE MEDIATEK SOFTWARE AT ISSUE,
+ * * OR REFUND ANY SOFTWARE LICENSE FEES OR SERVICE CHARGE PAID BY RECEIVER TO
+ * * MEDIATEK FOR SUCH MEDIATEK SOFTWARE AT ISSUE.
+ * *
+ * * The following software/firmware and/or related documentation ("MediaTek Software")
+ * * have been modified by MediaTek Inc. All revisions are subject to any receiver's
+ * * applicable license agreements with MediaTek Inc.
+ * */
+
+#pragma once
+
+/******************************************************************************
+ * **
+ * ** General Config
+ * **
+ * ******************************************************************************/
+
+#if __STDC_VERSION__ < 199901L
+#  ifndef FALSE
+#    define FALSE 0
+#  endif
+#  ifndef TRUE
+#    define TRUE (!FALSE)
+#  endif
+#else
+#  include <stdbool.h>
+#  ifndef FALSE
+#    define FALSE  false
+#  endif
+#  ifndef TRUE
+#    define TRUE   true
+#  endif
+#endif
+
+#ifdef MTK_BT_COMMON
+#define MTK_COMMON                     TRUE
+
+// #define BT_TRACE_VERBOSE            TRUE
+// #define SMP_DEBUG                   TRUE
+// #define SDP_DEBUG_RAW               TRUE
+
+/******************************************************************************
+ * **
+ * ** MTK BT feature option
+ * **
+ * ******************************************************************************/
+
+/* MTK config in bt_stack.conf */
+#ifndef MTK_STACK_CONFIG
+#define MTK_STACK_CONFIG               TRUE
+#endif
+
+#if MTK_STACK_CONFIG == TRUE
+
+#define MTK_STACK_CONFIG_VALUE_SEPARATOR ","
+#define MTK_STACK_CONFIG_PARTIAL_NAME_VALUE_MAX 1024
+
+#define MTK_STACK_CONFIG_FPATH_LEN 1024
+#define MTK_STACK_CONFIG_NUM_OF_HEXLIST 5
+#define MTK_STACK_CONFIG_NUM_OF_HEXITEMS 260
+#define MTK_STACK_CONFIG_NUM_OF_HEXROWITEMS 16
+#define MTK_STACK_CONFIG_NUM_OF_HEXCOLUMNITEMS 16
+
+/* Role switch & sniff subrating blacklist */
+#ifndef MTK_STACK_CONFIG_BL
+#define MTK_STACK_CONFIG_BL            TRUE
+#endif
+
+/* fwlog hcl hexlist */
+#ifndef MTK_STACK_CONFIG_LOG
+#define MTK_STACK_CONFIG_LOG           TRUE
+#endif
+
+/* Enable BT log on userdebug/eng Load w/o BTLogger */
+#ifdef MTK_BT_DEFAULT_OVERRIDE
+#define MTK_STACK_CONFIG_DEFAULT_OVERRIDE FALSE
+#endif
+
+/* Blueangel to Bluedroid paired device database convert */
+#ifndef MTK_STACK_BA2BD_CONVERT
+#define MTK_STACK_BA2BD_CONVERT TRUE
+#endif//MTK_STACK_BA2BD_CONVERT
+
+#endif /* MTK_STACK_CONFIG == TRUE */
+
+/******************************************************************************
+ * **
+ * ** BLE
+ * **
+ * ******************************************************************************/
+
+/*For MTK solution, vendor specific extensions is supported by default*/
+#ifndef BLE_VND_INCLUDED
+#define BLE_VND_INCLUDED               TRUE
+#endif
+
+/*For MTK BT chip, set below CE length*/
+#ifndef MTK_BLE_CONN_MIN_CE_LEN
+#define MTK_BLE_CONN_MIN_CE_LEN    0x0060
+#endif
+
+#ifndef MTK_BLE_CONN_MAX_CE_LEN
+#define MTK_BLE_CONN_MAX_CE_LEN    0x0140
+#endif
+
+/******************************************************************************
+**
+** GKI Buffer Pools
+**
+******************************************************************************/
+/* Pool ID where to reassemble the SDU.
+This Pool allows buffers to be used that are larger than
+the L2CAP_MAX_MTU. */
+#ifndef MTK_AVCT_BR_USER_RX_BUFFER_SIZE
+#define MTK_AVCT_BR_USER_RX_BUFFER_SIZE     BT_DEFAULT_BUFFER_SIZE
+#endif
+
+/* Pool ID where to hold the SDU.
+This Pool allows buffers to be used that are larger than
+the L2CAP_MAX_MTU. */
+#ifndef MTK_AVCT_BR_USER_TX_BUFFER_SIZE
+#define MTK_AVCT_BR_USER_TX_BUFFER_SIZE     BT_DEFAULT_BUFFER_SIZE
+#endif
+
+/*
+GKI Buffer Pool ID used to hold MPS segments during SDU reassembly
+*/
+#ifndef MTK_AVCT_BR_FCR_RX_BUFFER_SIZE
+#define MTK_AVCT_BR_FCR_RX_BUFFER_SIZE      BT_DEFAULT_BUFFER_SIZE
+#endif
+
+/*
+GKI Buffer Pool ID used to hold MPS segments used in (re)transmissions.
+L2CAP_DEFAULT_ERM_POOL_ID is specified to use the HCI ACL data pool.
+Note:  This pool needs to have enough buffers to hold two times the window size negotiated
+in the tL2CAP_FCR_OPTIONS (2 * tx_win_size)  to allow for retransmissions.
+The size of each buffer must be able to hold the maximum MPS segment size passed in
+tL2CAP_FCR_OPTIONS plus BT_HDR (8) + HCI preamble (4) + L2CAP_MIN_OFFSET (11 - as of BT 2.1 + EDR Spec).
+*/
+#ifndef MTK_AVCT_BR_FCR_TX_BUFFER_SIZE
+#define MTK_AVCT_BR_FCR_TX_BUFFER_SIZE      BT_DEFAULT_BUFFER_SIZE
+#endif
+
+/******************************************************************************
+ * **
+ * ** Advanced Audio Distribution Profile (A2DP)
+ * **
+ * ******************************************************************************/
+
+/* A2DP advanced codec support */
+
+/* support A2DP SRC AAC codec */
+/* Please enable this feature by changing option value defined here*/
+#ifndef MTK_A2DP_SRC_AAC_CODEC
+#define MTK_A2DP_SRC_AAC_CODEC  TRUE
+#endif
+
+/* support A2DP SRC APTX codec */
+/* Please enable this feature by adding feature option in ProjectConfig.mk*/
+#ifdef MTK_BT_A2DP_SRC_APTX_CODEC
+#define MTK_A2DP_SRC_APTX_CODEC  TRUE
+#endif
+
+/* Content protection: SCMS_T switch */
+#ifndef BTA_AV_CO_CP_SCMS_T
+#define BTA_AV_CO_CP_SCMS_T  TRUE
+#endif
+
+/* support a2dp audio dump debug feature */
+#ifndef MTK_A2DP_PCM_DUMP
+#define MTK_A2DP_PCM_DUMP TRUE
+#endif
+
+/* BTIF_MEDIA_FR_PER_TICKS_44_1_APTX: considering 1 frame as 16 aptX samples (4 bytes per sample)
+  1 sample duration(us) = 4 * 1000000/44100
+  13.75 frames/tick @ 20 ms tick (1 out of 4 frames sends one less) */
+#define BTIF_MEDIA_FR_PER_TICKS_44_1_APTX (14)
+
+/* Parameters relate to AAC codec */
+#define MTK_A2DP_AAC_DEFAULT_BIT_RATE 200000
+#define MTK_A2DP_BTIF_MEDIA_FR_PER_TICKS_AAC MTK_A2DP_BTIF_MEDIA_TIME_EXT
+#define MTK_A2DP_AAC_ENC_INPUT_BUF_SIZE (4*1024)
+#define MTK_A2DP_AAC_ENC_OUTPUT_BUF_SIZE (4*1024)
+#define MTK_A2DP_AAC_READ_BUF_SIZE (BTIF_MEDIA_TIME_TICK * 44100 / 1000 * 2 * 2)
+#define MTK_A2DP_AAC_LIMIT_MTU_SIZE (800)
+
+/*For Low power bug fix*/
+#define BTIF_MEDIA_NUM_TICK 1
+#define MTK_A2DP_BTIF_MEDIA_TIME_EXT (3)
+#define BTIF_MEDIA_TIME_TICK    (20 * BTIF_MEDIA_NUM_TICK * MTK_A2DP_BTIF_MEDIA_TIME_EXT)
+#define MAX_PCM_FRAME_NUM_PER_TICK    14 * MTK_A2DP_BTIF_MEDIA_TIME_EXT
+#define MAX_PCM_ITER_NUM_PER_TICK    3 * MTK_A2DP_BTIF_MEDIA_TIME_EXT
+#define MAX_OUTPUT_A2DP_FRAME_QUEUE_SZ (MAX_PCM_FRAME_NUM_PER_TICK * 2)
+#define A2DP_DATA_READ_POLL_MS    (BTIF_MEDIA_TIME_TICK / 2 / MTK_A2DP_BTIF_MEDIA_TIME_EXT)
+
+/******************************************************************************
+ * **
+ * ** Audio/Video Remote Control Profile (AVRCP)
+ * **
+ * ******************************************************************************/
+#ifdef MTK_BT_AVRCP_TG_16
+
+#define MTK_AVRCP_TG_15 TRUE
+#define MTK_AVRCP_TG_16 TRUE
+
+#define MTK_BT_PSM_COVER_ART 0x1077
+#endif
+
+
+#ifdef MTK_BT_AVRCP_TG_15
+
+/* support AVRCP 1.5 version target role
+Following features are included
+1. Media player selection is mandandory (if support catogary 1)
+2. Get Folder Item - media player list (if support catogary 1)
+3. SDP record for AVRCP 1.5 */
+#ifndef MTK_AVRCP_TG_15
+#define MTK_AVRCP_TG_15 TRUE
+#endif
+
+#define MTK_AVRCP_VERSION_SDP_POSITION 7
+#define MTK_AVRCP_13_VERSION 0x03
+#define MTK_AVRCP_14_VERSION 0x04
+
+#endif /* ifdef MTK_BT_AVRCP_TG_15 */
+
+/******************************************************************************
+ * **
+ * ** Audio/Video Control Transport Protocol (AVCTP)
+ * **
+ * ******************************************************************************/
+
+#if MTK_AVRCP_TG_15 == TRUE
+
+/* enable AOSP avct browse included */
+#define AVCT_BROWSE_INCLUDED        TRUE
+
+#define MTK_AVCT_BROWSE_INCLUDED TRUE
+
+#endif /* ifdef MTK_BT_AVRCP_TG_15 */
+
+/* AVCTP Browsing channel FCR Option:
+Size of the transmission window when using enhanced retransmission mode. Not used
+in basic and streaming modes. Range: 1 - 63
+*/
+#ifndef MTK_AVCT_BR_FCR_OPT_TX_WINDOW_SIZE
+#define MTK_AVCT_BR_FCR_OPT_TX_WINDOW_SIZE      10
+#endif
+
+/* AVCTP Browsing channel FCR Option:
+Number of transmission attempts for a single I-Frame before taking
+Down the connection. Used In ERTM mode only. Value is Ignored in basic and
+Streaming modes.
+Range: 0, 1-0xFF
+0 - infinite retransmissions
+1 - single transmission
+*/
+#ifndef MTK_AVCT_BR_FCR_OPT_MAX_TX_B4_DISCNT
+#define MTK_AVCT_BR_FCR_OPT_MAX_TX_B4_DISCNT    20
+#endif
+
+/* AVCTP Browsing channel FCR Option: Retransmission Timeout
+The AVRCP specification set a value in the range of 300 - 2000 ms
+Timeout (in msecs) to detect Lost I-Frames. Only used in Enhanced retransmission mode.
+Range: Minimum 2000 (2 secs) when supporting PBF.
+*/
+#ifndef MTK_AVCT_BR_FCR_OPT_RETX_TOUT
+#define MTK_AVCT_BR_FCR_OPT_RETX_TOUT           2000
+#endif
+
+/* AVCTP Browsing channel FCR Option: Monitor Timeout
+The AVRCP specification set a value in the range of 300 - 2000 ms
+Timeout (in msecs) to detect Lost S-Frames. Only used in Enhanced retransmission mode.
+Range: Minimum 12000 (12 secs) when supporting PBF.
+*/
+#ifndef MTK_AVCT_BR_FCR_OPT_MONITOR_TOUT
+#define MTK_AVCT_BR_FCR_OPT_MONITOR_TOUT        12000
+#endif
+
+/* AVCTP browsing channel FCR Option: Maximum PDU payload size.
+The maximum number of payload octets that the local device can receive in a single PDU.
+*/
+#ifndef MTK_AVCT_BR_FCR_OPT_MPS_SIZE
+#define MTK_AVCT_BR_FCR_OPT_MPS_SIZE            1000
+#endif
+
+/******************************************************************************
+ * **
+ * ** HANDS FREE PROFILE (HFP)
+ * **
+ * ******************************************************************************/
+
+#ifdef MTK_BT_HFP_DUAL_HF
+/*Dual HandsFree feature*/
+#define MTK_HFP_DUAL_HF      TRUE
+#endif /* #ifdef MTK_BT_HFP_DUAL_HF */
+
+/* Wide Band Speech */
+#ifndef MTK_HFP_WBS
+#define MTK_HFP_WBS                 TRUE
+#endif
+
+/* In-band Ringtone */
+#ifndef MTK_HFP_INBAND_RING
+#define MTK_HFP_INBAND_RING         FALSE
+#endif
+
+#if MTK_HFP_WBS == TRUE
+#ifndef BTM_WBS_INCLUDED
+#define BTM_WBS_INCLUDED            TRUE
+#endif
+
+#ifndef BTIF_HF_WBS_PREFERRED
+#define BTIF_HF_WBS_PREFERRED       TRUE
+#endif
+#endif /* if MTK_HFP_WBS == TRUE */
+
+/******************************************************************************
+ * **
+ * ** dial-up networking (DUN)
+ * **
+ * ******************************************************************************/
+
+#ifdef MTK_BT_DUN_GW_12
+#define MTK_DUN_GW_12               TRUE
+#endif
+
+/******************************************************************************
+ * **
+ * ** Detect Chip Reset
+ * **
+ * ******************************************************************************/
+
+/* Support handle trigger FW core dump and monitor chip-reset in hci layer.*/
+/* Must be TRUE */
+#define MTK_SUPPORT_FW_CORE_DUMP  TRUE
+
+/******************************************************************************
+ * **
+ * ** New MTK Vendor Opcodes
+ * **
+ * ******************************************************************************/
+
+/* Enable MTK-owned vendor opcode. */
+/* Must be TRUE */
+#define MTK_VENDOR_OPCODE      TRUE
+
+/******************************************************************************
+* **
+ * ** MTK Power Saving Mode Ctrl by HCI Interface
+* **
+******************************************************************************/
+/* Support PSM Mode in HCI Interface. */
+#define MTK_HCI_POWERSAVING_MODE TRUE
+
+/******************************************************************************
+ * **
+ * ** BT Snoop Log
+ * **
+ * ******************************************************************************/
+
+/* Create a thread for accessing file i/o of btsnoop log. */
+#ifndef MTK_BTSNOOPLOG_THREAD
+#define MTK_BTSNOOPLOG_THREAD      TRUE
+#endif
+
+/* Default enable customize snnop log mode*/
+#ifndef MTK_BTSNOOPLOG_MODE_SUPPRT
+#define MTK_BTSNOOPLOG_MODE_SUPPRT TRUE
+#endif
+
+/******************************************************************************
+**
+** ATT/GATT Protocol/Profile Settings
+**
+******************************************************************************/
+#ifndef BTA_DM_GATT_CLOSE_DELAY_TOUT
+#define BTA_DM_GATT_CLOSE_DELAY_TOUT    1500
+#endif
+
+/******************************************************************************
+**
+** HID/HOGP Profile Settings
+**
+******************************************************************************/
+#ifndef MTK_HID_IOT_MOUSE_IME
+#define MTK_HID_IOT_MOUSE_IME    TRUE
+#endif
+
+#ifdef MTK_BT_KERNEL_3_18
+#define MTK_HID_DRIVER_KERNEL_3_18    TRUE
+#endif
+
+#if MTK_COMMON == TRUE
+#ifdef MTK_BT_KERNEL_4_4
+#define MTK_HID_DRIVER_KERNEL_4_4    TRUE
+#endif
+#endif
+
+/******************************************************************************
+ * **
+ * **
+ * **
+ * ******************************************************************************/
+
+#endif /* ifdef MTK_BT_COMMON */
diff --git a/audio_a2dp_hw/mediatek/include/mdroid_stack_config.h b/audio_a2dp_hw/mediatek/include/mdroid_stack_config.h
new file mode 100644
index 00000000..e8150793
--- /dev/null
+++ b/audio_a2dp_hw/mediatek/include/mdroid_stack_config.h
@@ -0,0 +1,18 @@
+#pragma once
+
+#include <stdbool.h>
+
+#include "osi/include/config.h"
+
+#if MTK_STACK_CONFIG_LOG == TRUE
+typedef struct {
+  bool (*get_pack_hexlists)(void);
+  const uint8_t *(*get_whole_hexlists)(void);
+} stack_config_pack_hexlist_t;
+
+const stack_config_pack_hexlist_t *stack_config_fwlog_hexs_get_interface();
+#endif
+
+#if MTK_STACK_CONFIG == TRUE
+extern bool parse_override_cfg(config_t * config);
+#endif
diff --git a/audio_a2dp_hw/mediatek/include/twrite.h b/audio_a2dp_hw/mediatek/include/twrite.h
new file mode 100644
index 00000000..06f11663
--- /dev/null
+++ b/audio_a2dp_hw/mediatek/include/twrite.h
@@ -0,0 +1,31 @@
+#pragma once
+
+typedef enum {
+  // Default log mode, log file size is unlimited
+  BTSNOOP_LOG_MODE_DEFAULT,
+  // Alone log mode descroption:
+  //   1. Hci log is a single file, and its size is limited to 300M;
+  //   2. If Log file is larger then 300M, it would override the old log record,
+  //    which likes a file ring buffer;
+  // Alone log mode and default log mode relationship:
+  //   1. If default mode and alone log mode are both open before opening Bluetooth,
+  //     default mode should be taken;
+  //   2. otherwise, mode log setting should take effect after reopen Bluetooth.
+  // How to enable alone log mode
+  //   1. Set MTK_BTSNOOPLOG_MODE_SUPPRT to "TRUE" in mdroid_buildcfg.h,
+  //   2. Set system property "bt.hcilogalone" to "1"
+  BTSNOOP_LOG_MODE_ALONE
+} BTSNOOP_LOG_MODE;
+
+typedef void (*SNOOP_WRITE)(const void *data, size_t length);
+
+bool twrite_init(const char * log_path, BTSNOOP_LOG_MODE log_mode, int * fd);
+int twrite_deinit();
+int twrite_write(const unsigned char *data, int len);
+
+void twrite_write_packet(SNOOP_WRITE btsnoop_write, int type,
+    const uint8_t *packet, int length_he_in, int length_in, int flags_in,
+    int drops_in, uint32_t time_hi_in, uint32_t time_lo_in);
+
+bool enable_mtk_btsnoop();
+
diff --git a/audio_a2dp_hw/mediatek/interop/interop_mtk.c b/audio_a2dp_hw/mediatek/interop/interop_mtk.c
new file mode 100644
index 00000000..2803ced0
--- /dev/null
+++ b/audio_a2dp_hw/mediatek/interop/interop_mtk.c
@@ -0,0 +1,99 @@
+/* Copyright Statement:
+ * *
+ * * This software/firmware and related documentation ("MediaTek Software") are
+ * * protected under relevant copyright laws. The information contained herein
+ * * is confidential and proprietary to MediaTek Inc. and/or its licensors.
+ * * Without the prior written permission of MediaTek inc. and/or its licensors,
+ * * any reproduction, modification, use or disclosure of MediaTek Software,
+ * * and information contained herein, in whole or in part, shall be strictly prohibited.
+ * *
+ * * MediaTek Inc. (C) 2010. All rights reserved.
+ * *
+ * * BY OPENING THIS FILE, RECEIVER HEREBY UNEQUIVOCALLY ACKNOWLEDGES AND AGREES
+ * * THAT THE SOFTWARE/FIRMWARE AND ITS DOCUMENTATIONS ("MEDIATEK SOFTWARE")
+ * * RECEIVED FROM MEDIATEK AND/OR ITS REPRESENTATIVES ARE PROVIDED TO RECEIVER ON
+ * * AN "AS-IS" BASIS ONLY. MEDIATEK EXPRESSLY DISCLAIMS ANY AND ALL WARRANTIES,
+ * * EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE IMPLIED WARRANTIES OF
+ * * MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE OR NONINFRINGEMENT.
+ * * NEITHER DOES MEDIATEK PROVIDE ANY WARRANTY WHATSOEVER WITH RESPECT TO THE
+ * * SOFTWARE OF ANY THIRD PARTY WHICH MAY BE USED BY, INCORPORATED IN, OR
+ * * SUPPLIED WITH THE MEDIATEK SOFTWARE, AND RECEIVER AGREES TO LOOK ONLY TO SUCH
+ * * THIRD PARTY FOR ANY WARRANTY CLAIM RELATING THERETO. RECEIVER EXPRESSLY ACKNOWLEDGES
+ * * THAT IT IS RECEIVER'S SOLE RESPONSIBILITY TO OBTAIN FROM ANY THIRD PARTY ALL PROPER LICENSES
+ * * CONTAINED IN MEDIATEK SOFTWARE. MEDIATEK SHALL ALSO NOT BE RESPONSIBLE FOR ANY MEDIATEK
+ * * SOFTWARE RELEASES MADE TO RECEIVER'S SPECIFICATION OR TO CONFORM TO A PARTICULAR
+ * * STANDARD OR OPEN FORUM. RECEIVER'S SOLE AND EXCLUSIVE REMEDY AND MEDIATEK'S ENTIRE AND
+ * * CUMULATIVE LIABILITY WITH RESPECT TO THE MEDIATEK SOFTWARE RELEASED HEREUNDER WILL BE,
+ * * AT MEDIATEK'S OPTION, TO REVISE OR REPLACE THE MEDIATEK SOFTWARE AT ISSUE,
+ * * OR REFUND ANY SOFTWARE LICENSE FEES OR SERVICE CHARGE PAID BY RECEIVER TO
+ * * MEDIATEK FOR SUCH MEDIATEK SOFTWARE AT ISSUE.
+ * *
+ * * The following software/firmware and/or related documentation ("MediaTek Software")
+ * * have been modified by MediaTek Inc. All revisions are subject to any receiver's
+ * * applicable license agreements with MediaTek Inc.
+ * */
+
+
+/******************************************************************************
+ *
+ *  This file contains functions for the MTK defined interop function
+ *
+ ******************************************************************************/
+#define LOG_TAG "bt_device_interop_mtk"
+
+#include <stdlib.h>
+#include <string.h>
+#include <stddef.h>
+
+#if MTK_STACK_CONFIG_BL == TRUE
+#include "bdaddr.h"
+#include "bt_types.h"
+#include "osi/include/log.h"
+#include "btif/include/btif_config.h"
+#include "btm_api.h"
+#include "interop_mtk.h"
+
+bt_status_t btmtk_get_ble_device_name(const bt_bdaddr_t *remote_bd_addr, BD_NAME bd_name)
+{
+    bdstr_t bdstr;
+    int length = BD_NAME_LEN;
+    bdaddr_to_string(remote_bd_addr, bdstr, sizeof(bdstr));
+    int ret = btif_config_get_str(bdstr, "Name", (char*)bd_name, &length);
+    return ret ? BT_STATUS_SUCCESS : BT_STATUS_FAIL;
+}
+
+bool interop_mtk_match_name(const interop_feature_t feature, const bt_bdaddr_t* addr)
+{
+    char *dev_name_str;
+    BD_NAME remote_name = {0};
+    BD_ADDR bd_addr;
+
+    bdcpy(bd_addr, addr->address);
+    dev_name_str = BTM_SecReadDevName(bd_addr);
+
+    //need to load ble device name from config
+    if (dev_name_str == NULL || dev_name_str[0] == '\0')
+    {
+        dev_name_str = (char *)remote_name;
+        btmtk_get_ble_device_name(addr, remote_name);
+    }
+
+    if (dev_name_str != NULL && dev_name_str[0] != '\0')
+    {
+        char bdstr[20] = {0};
+        LOG_DEBUG(LOG_TAG, "%s match device %s(%s) for interop workaround.", __func__,
+            dev_name_str, bdaddr_to_string(addr, bdstr, sizeof(bdstr)));
+
+        return interop_match_name(feature, (const char *)dev_name_str);
+    }
+    return false;
+}
+
+bool interop_mtk_match_addr_name(const interop_feature_t feature, const bt_bdaddr_t* addr)
+{
+    if(interop_match_addr(feature, addr))
+        return true;
+
+    return interop_mtk_match_name(feature, addr);
+}
+#endif
diff --git a/btif/src/btif_media_task.c b/btif/src/btif_media_task.c
index 977d2668..6373113d 100644
--- a/btif/src/btif_media_task.c
+++ b/btif/src/btif_media_task.c
@@ -98,7 +98,6 @@
 #include "btif_avrcp_audio_track.h"
 #endif
 
-#include "bthost_ipc.h"
 #if (BTA_AV_SINK_INCLUDED == TRUE)
 OI_CODEC_SBC_DECODER_CONTEXT context;
 OI_UINT32 contextData[CODEC_DATA_WORDS(2, SBC_CODEC_FAST_FILTER_BUFFERS)];
@@ -531,7 +530,6 @@ BOOLEAN bta_av_co_audio_get_codec_config(UINT8 *p_config, UINT16 *p_minmtu, UINT
 
 extern BOOLEAN bt_split_a2dp_enabled;
 extern int btif_max_av_clients;
-static uint8_t multicast_query = FALSE;
 /*****************************************************************************
  **  Misc helper functions
  *****************************************************************************/
@@ -729,11 +727,7 @@ static const char* dump_a2dp_ctrl_event(UINT8 event)
         CASE_RETURN_STR(A2DP_CTRL_CMD_STOP)
         CASE_RETURN_STR(A2DP_CTRL_CMD_SUSPEND)
         CASE_RETURN_STR(A2DP_CTRL_CMD_OFFLOAD_START)
-        CASE_RETURN_STR(A2DP_CTRL_CMD_OFFLOAD_SUPPORTED)
-        CASE_RETURN_STR(A2DP_CTRL_CMD_OFFLOAD_NOT_SUPPORTED)
-        CASE_RETURN_STR(A2DP_CTRL_GET_CODEC_CONFIG)
-        CASE_RETURN_STR(A2DP_CTRL_GET_MULTICAST_STATUS)
-        CASE_RETURN_STR(A2DP_CTRL_GET_CONNECTION_STATUS)
+
         default:
             return "UNKNOWN MSG ID";
     }
@@ -741,7 +735,7 @@ static const char* dump_a2dp_ctrl_event(UINT8 event)
 
 static void btif_audiopath_detached(void)
 {
-    APPL_TRACE_IMP("## AUDIO PATH DETACHED ##");
+    APPL_TRACE_EVENT("## AUDIO PATH DETACHED ##");
 
     /*  send stop request only if we are actively streaming and haven't received
         a stop request. Potentially audioflinger detached abnormally */
@@ -755,7 +749,7 @@ static void a2dp_cmd_acknowledge(int status)
 {
     UINT8 ack = status;
 
-    APPL_TRACE_IMP("## a2dp ack : %s, status %d ##",
+    APPL_TRACE_EVENT("## a2dp ack : %s, status %d ##",
           dump_a2dp_ctrl_event(btif_media_cb.a2dp_cmd_pending), status);
 
     /* sanity check */
@@ -782,7 +776,7 @@ static void btif_recv_ctrl_data(void)
     /* detach on ctrl channel means audioflinger process was terminated */
     if (n == 0)
     {
-        APPL_TRACE_IMP("CTRL CH DETACHED");
+        APPL_TRACE_EVENT("CTRL CH DETACHED");
         UIPC_Close(UIPC_CH_ID_AV_CTRL);
         /* we can operate only on datachannel, if af client wants to
            do send additional commands the ctrl channel would be reestablished */
@@ -790,7 +784,7 @@ static void btif_recv_ctrl_data(void)
         return;
     }
 
-    APPL_TRACE_IMP("a2dp-ctrl-cmd : %s", dump_a2dp_ctrl_event(cmd));
+    APPL_TRACE_DEBUG("a2dp-ctrl-cmd : %s", dump_a2dp_ctrl_event(cmd));
 
     btif_media_cb.a2dp_cmd_pending = cmd;
 
@@ -819,14 +813,6 @@ static void btif_recv_ctrl_data(void)
             }
             break;
 
-        case A2DP_CTRL_CMD_CHECK_STREAM_STARTED:
-
-            if((btif_av_stream_started_ready() == TRUE))
-                a2dp_cmd_acknowledge(A2DP_CTRL_ACK_SUCCESS);
-            else
-                a2dp_cmd_acknowledge(A2DP_CTRL_ACK_FAILURE);
-            break;
-
         case A2DP_CTRL_CMD_START:
             /* Don't sent START request to stack while we are in call.
                Some headsets like the Sony MW600, don't allow AVDTP START
@@ -837,6 +823,7 @@ static void btif_recv_ctrl_data(void)
                 break;
             }
 
+
             if (alarm_is_scheduled(btif_media_cb.media_alarm))
             {
                 APPL_TRACE_WARNING("%s: A2DP command %s when media alarm already scheduled",
@@ -845,41 +832,24 @@ static void btif_recv_ctrl_data(void)
                 break;
             }
 
-            /* In Dual A2dp, first check for started state of stream
-            * as we dont want to START again as while doing Handoff
-            * the stack state will be started, so it is not needed
-            * to send START again, just open the media socket
-            * and ACK the audio HAL.*/
-            if (btif_av_stream_started_ready())
+
+#if MTK_STACK_CONFIG_BL == TRUE
+            /***
+             * Check the remote device. If it special device, will
+             * break this loop and delay for 1s. After 1s, it will call
+             * btif_media_av_delay_start_cmd_hdlr to go on.
+             */
+            if(btif_av_is_black_peer())
             {
-                if (!bt_split_a2dp_enabled)
-                {
-                    /* already started, setup audio data channel listener
-                    * and ack back immediately */
-                    UIPC_Open(UIPC_CH_ID_AV_AUDIO, btif_a2dp_data_cb);
-                }
-                else
-                {
-                    //UIPC_Open(UIPC_CH_ID_AV_AUDIO, btif_a2dp_data_cb);//Test Remove later
-                    APPL_TRACE_DEBUG("Av stream alreday started");
-                    if (btif_media_cb.peer_sep == AVDT_TSEP_SNK)
-                        btif_a2dp_encoder_update();
-                }
-                a2dp_cmd_acknowledge(A2DP_CTRL_ACK_SUCCESS);
+                APPL_TRACE_EVENT("Break and delay 1s for START cmd");
+                break;
             }
-            else if (btif_av_stream_ready() == TRUE)
+#endif
+            if (btif_av_stream_ready() == TRUE)
             {
                 /* setup audio data channel listener */
-                if (!bt_split_a2dp_enabled)
-                {
-                    /* already started, setup audio data channel listener
-                    * and ack back immediately */
-                    UIPC_Open(UIPC_CH_ID_AV_AUDIO, btif_a2dp_data_cb);
-                }
-                else
-                {
-                    APPL_TRACE_DEBUG("Av stream ready");
-                }
+                UIPC_Open(UIPC_CH_ID_AV_AUDIO, btif_a2dp_data_cb);
+
                 /* post start event and wait for audio path to open */
                 btif_dispatch_sm_event(BTIF_AV_START_STREAM_REQ_EVT, NULL, 0);
 
@@ -888,6 +858,14 @@ static void btif_recv_ctrl_data(void)
                     a2dp_cmd_acknowledge(A2DP_CTRL_ACK_SUCCESS);
 #endif
             }
+            else if (btif_av_stream_started_ready())
+            {
+                /* already started, setup audio data channel listener
+                   and ack back immediately */
+                UIPC_Open(UIPC_CH_ID_AV_AUDIO, btif_a2dp_data_cb);
+
+                a2dp_cmd_acknowledge(A2DP_CTRL_ACK_SUCCESS);
+            }
             else
             {
                 APPL_TRACE_WARNING("%s: A2DP command %s while AV stream is not ready",
@@ -898,19 +876,15 @@ static void btif_recv_ctrl_data(void)
             break;
 
         case A2DP_CTRL_CMD_STOP:
-            if ((!bt_split_a2dp_enabled && btif_media_cb.peer_sep == AVDT_TSEP_SNK &&
-                 (!alarm_is_scheduled(btif_media_cb.media_alarm))) ||
-                (bt_split_a2dp_enabled &&  btif_media_cb.peer_sep == AVDT_TSEP_SNK &&
-                 btif_media_cb.tx_started == FALSE))
+            if (btif_media_cb.peer_sep == AVDT_TSEP_SNK &&
+                (!alarm_is_scheduled(btif_media_cb.media_alarm)))
             {
                 /* we are already stopped, just ack back */
                 a2dp_cmd_acknowledge(A2DP_CTRL_ACK_SUCCESS);
                 break;
             }
 
-            APPL_TRACE_DEBUG("Stop stream request to Av");
             btif_dispatch_sm_event(BTIF_AV_STOP_STREAM_REQ_EVT, NULL, 0);
-
             a2dp_cmd_acknowledge(A2DP_CTRL_ACK_SUCCESS);
             break;
 
@@ -918,16 +892,8 @@ static void btif_recv_ctrl_data(void)
             /* local suspend */
             if (btif_av_stream_started_ready())
             {
-                APPL_TRACE_DEBUG("Suspend stream request to Av");
                 btif_dispatch_sm_event(BTIF_AV_SUSPEND_STREAM_REQ_EVT, NULL, 0);
             }
-            else if (bt_split_a2dp_enabled && btif_av_is_under_handoff())
-            {
-                /* Do nothing when handoff is in progress. On suspend cfm, a2dp cmd will
-                   be acknowledged. ACKing might lead to wrong codec config will be updated
-                   to hal during multi-codec connection */
-                APPL_TRACE_DEBUG("AV is under handoff");
-            }
             else
             {
                 /* if we are not in started state, just ack back ok and let
@@ -948,195 +914,24 @@ static void btif_recv_ctrl_data(void)
             UIPC_Send(UIPC_CH_ID_AV_CTRL, 0, &channel_count, 1);
             break;
         }
+
         case A2DP_CTRL_CMD_OFFLOAD_START:
                 btif_dispatch_sm_event(BTIF_AV_OFFLOAD_START_REQ_EVT, NULL, 0);
             break;
-        case A2DP_CTRL_GET_CODEC_CONFIG:
-        {
-            UINT16 min_mtu;
-            uint8_t param[MAX_CODEC_CFG_SIZE],idx,bta_hdl,codec_id = 0;
-            uint32_t bitrate = 0;
-            uint8_t i = 0;
-            UIPC_Read(UIPC_CH_ID_AV_CTRL, NULL, &idx, 1);
-            memset(param,0,MAX_CODEC_CFG_SIZE);
-
-            if (btif_av_stream_started_ready() == FALSE)
-            {
-                BTIF_TRACE_ERROR("A2DP_CTRL_GET_CODEC_CONFIG: stream not started");
-                a2dp_cmd_acknowledge(A2DP_CTRL_ACK_FAILURE);
-                break;
-            }
-            /*
-            If multicast is supported, codec config will be queried
-            successively for num of playing devices
-            */
-            if (multicast_query)
-            {
-                if (idx == (btif_max_av_clients-1))
-                {
-                    multicast_query = FALSE;
-                    //Get AV handle of index 1
-                }
-                BTIF_TRACE_DEBUG("Mulitcast Enabled, querying index =%d",idx);
 
-                bta_hdl = btif_av_get_av_hdl_from_idx(idx);
-                if (bta_hdl < 0)
-                {
-                    a2dp_cmd_acknowledge(A2DP_CTRL_ACK_FAILURE);
-                    break;
-                }
-                //TODO Maintain selected codec info for Multicast with different codecs
-            }
-            else //get playing device hdl
-            {
-                codec_id =  bta_av_co_get_current_codec();
-            }
-
-            a2dp_cmd_acknowledge(A2DP_CTRL_ACK_SUCCESS);
-            BTIF_TRACE_DEBUG("codec_id = %x",codec_id);
-
-            if (get_soc_type() == BT_SOC_SMD)
-            {
-                //For Pronto PLs Audio pumps raw PCM data for others its encoded data to SOC
-                param[1] = 4; //RAW PCM
-                param[2] = AVDT_MEDIA_AUDIO;
-                param[3] = BTIF_AV_CODEC_PCM;
-                param[4] = btif_media_cb.media_feeding.cfg.pcm.sampling_freq;
-                param[5] = btif_media_cb.media_feeding.cfg.pcm.num_channel;
-            }
-            else if (codec_id == BTIF_AV_CODEC_SBC)
-            {
-                tA2D_SBC_CIE codec_cfg;
-                bta_av_co_audio_get_sbc_config(&codec_cfg, &min_mtu);
-                A2D_BldSbcInfo(AVDT_MEDIA_AUDIO,&codec_cfg,&param[1]);
-                bitrate = btif_media_cb.encoder.u16BitRate * 1000;
-            }
-#if defined(AAC_ENCODER_INCLUDED) && (AAC_ENCODER_INCLUDED == TRUE)
-            else if (codec_id == BTIF_AV_CODEC_M24) {
-                tA2D_AAC_CIE aac_cfg;
-                bta_av_co_audio_get_aac_config(&aac_cfg, &min_mtu);
-                A2D_BldAacInfo(AVDT_MEDIA_AUDIO,&aac_cfg,&param[1]);
-                bitrate = btif_media_cb.encoder.u16BitRate * 1000;
-            }
-#endif
-            else if (codec_id == A2D_NON_A2DP_MEDIA_CT) //this is changed to non-a2dp VS codec
-            {
-               //ADD APTX support
-                UINT8* ptr = bta_av_co_get_current_codecInfo();
-                int j;
-                UINT8 *p_ptr = ptr;
-                for(j=0; j< (int)sizeof(tA2D_APTX_CIE);j++)
-                {
-                    BTIF_TRACE_DEBUG("codec[%d] = %x",j,*p_ptr++);
-                }
-                if (ptr)
-                {
-                    tA2D_APTX_CIE* codecInfo = 0;
-                    codecInfo = (tA2D_APTX_CIE*) &ptr[BTA_AV_CFG_START_IDX];
-                    if (codecInfo && codecInfo->vendorId == A2D_APTX_VENDOR_ID
-                        && codecInfo->codecId == A2D_APTX_CODEC_ID_BLUETOOTH)
-                    {
-                        tA2D_APTX_CIE aptx_config;
-                        memset(&aptx_config,0,sizeof(tA2D_APTX_CIE));
-                        aptx_config.vendorId = codecInfo->vendorId;
-                        aptx_config.codecId = codecInfo->codecId;
-                        aptx_config.sampleRate = codecInfo->sampleRate;
-                        aptx_config.channelMode = codecInfo->channelMode;
-                        BTIF_TRACE_DEBUG("vendor id = %x",aptx_config.vendorId);
-                        BTIF_TRACE_DEBUG("codec id = %x",aptx_config.codecId);
-                        BTIF_TRACE_DEBUG("sample rate  = %x",aptx_config.sampleRate);
-                        BTIF_TRACE_DEBUG("ch mode  = %x",aptx_config.channelMode);
-                        A2D_BldAptxInfo(AVDT_MEDIA_AUDIO,&aptx_config,&param[1]);
-
-                        /* For aptxClassic BR = (Sampl_Rate * PCM_DEPTH * CHNL)/Compression_Ratio */
-                        bitrate = ((btif_media_cb.media_feeding.cfg.pcm.sampling_freq * 16 * 2)/4);
-                    } else {
-                        tA2D_APTX_HD_CIE* cI = 0;
-                        cI = (tA2D_APTX_HD_CIE*) &ptr[BTA_AV_CFG_START_IDX];
-                        if (cI && cI->vendorId == A2D_APTX_HD_VENDOR_ID
-                        && cI->codecId == A2D_APTX_HD_CODEC_ID_BLUETOOTH)
-                        {
-                            tA2D_APTX_HD_CIE aptxhd_config;
-                            memset(&aptxhd_config,0,sizeof(tA2D_APTX_HD_CIE));
-                            aptxhd_config.vendorId = codecInfo->vendorId;
-                            aptxhd_config.codecId = codecInfo->codecId;
-                            aptxhd_config.sampleRate = codecInfo->sampleRate;
-                            aptxhd_config.channelMode = codecInfo->channelMode;
-                            BTIF_TRACE_DEBUG("vendor id = %x",aptxhd_config.vendorId);
-                            BTIF_TRACE_DEBUG("codec id = %x",aptxhd_config.codecId);
-                            BTIF_TRACE_DEBUG("sample rate  = %x",aptxhd_config.sampleRate);
-                            BTIF_TRACE_DEBUG("ch mode  = %x",aptxhd_config.channelMode);
-                            A2D_BldAptx_hdInfo(AVDT_MEDIA_AUDIO,&aptxhd_config,&param[1]);
-
-                            /* For aptxHD BR = (Sampl_Rate * PCM_DEPTH * CHNL)/Compression_Ratio,
-                               derived from classic */
-                            bitrate = ((btif_media_cb.media_feeding.cfg.pcm.sampling_freq * 16 * 2)/4);
-                       }
-                   }
-                }
-            }
-            param[0] = btif_get_latest_playing_device_idx();
-            i = param[1] + 2; //LOSC
-            param[i++] = (UINT8)(btif_media_cb.TxAaMtuSize & 0x00FF);
-            param[i++] = (UINT8)(((btif_media_cb.TxAaMtuSize & 0xFF00) >> 8) & 0x00FF);
-            param[i++] = (UINT8)(bitrate & 0x00FF);
-            param[i++] = (UINT8)(((bitrate & 0xFF00) >> 8) & 0x00FF);
-            param[i++] = (UINT8)(((bitrate & 0xFF0000) >> 16) & 0x00FF);
-            param[i++] = (UINT8)(((bitrate & 0xFF000000) >> 24) & 0x00FF);
-            UIPC_Send(UIPC_CH_ID_AV_CTRL, 0, &i, 1);
-            UIPC_Send(UIPC_CH_ID_AV_CTRL, 0, (UINT8 *)&param, i);
-            break;
-        }
-
-        case A2DP_CTRL_GET_MULTICAST_STATUS:
-        {
-            uint8_t playing_devices = (uint8_t)btif_av_get_num_playing_devices();
-            BOOLEAN multicast_state = btif_av_get_multicast_state();
-            a2dp_cmd_acknowledge(A2DP_CTRL_ACK_SUCCESS);
-            multicast_query = FALSE;
-            if ((btif_max_av_clients > 1 && playing_devices == btif_max_av_clients) &&
-                multicast_state)
-            {
-                multicast_query = TRUE;
-            }
-            BTIF_TRACE_ERROR("multicast status = %d",multicast_query);
-            UIPC_Send(UIPC_CH_ID_AV_CTRL, 0, &multicast_query, 1);
-            UIPC_Send(UIPC_CH_ID_AV_CTRL, 0, &playing_devices, 1);
-
-            break;
-        }
-        case A2DP_CTRL_CMD_OFFLOAD_SUPPORTED:
-            BTIF_TRACE_ERROR("Split A2DP supported");
-            bt_split_a2dp_enabled = TRUE;
-            a2dp_cmd_acknowledge(A2DP_CTRL_ACK_SUCCESS);
-            break;
-        case A2DP_CTRL_CMD_OFFLOAD_NOT_SUPPORTED:
-            BTIF_TRACE_ERROR("Split A2DP not supported");
-            bt_split_a2dp_enabled = FALSE; //Change to FALSE later
-            a2dp_cmd_acknowledge(A2DP_CTRL_ACK_SUCCESS);
-            break;
-        case A2DP_CTRL_GET_CONNECTION_STATUS:
-            if (btif_av_is_connected())
-            {
-                BTIF_TRACE_DEBUG("got valid connection");
-                a2dp_cmd_acknowledge(A2DP_CTRL_ACK_SUCCESS);
-            }
-            else
-                a2dp_cmd_acknowledge(A2DP_CTRL_ACK_FAILURE);
-            break;
         default:
             APPL_TRACE_ERROR("UNSUPPORTED CMD (%d)", cmd);
             a2dp_cmd_acknowledge(A2DP_CTRL_ACK_FAILURE);
             break;
     }
-    APPL_TRACE_IMP("a2dp-ctrl-cmd : %s DONE", dump_a2dp_ctrl_event(cmd));
+    APPL_TRACE_DEBUG("a2dp-ctrl-cmd : %s DONE", dump_a2dp_ctrl_event(cmd));
 }
 
 static void btif_a2dp_ctrl_cb(tUIPC_CH_ID ch_id, tUIPC_EVENT event)
 {
     UNUSED(ch_id);
 
-    APPL_TRACE_IMP("A2DP-CTRL-CHANNEL EVENT %s", dump_uipc_event(event));
+    APPL_TRACE_DEBUG("A2DP-CTRL-CHANNEL EVENT %s", dump_uipc_event(event));
 
     switch (event)
     {
@@ -1177,10 +972,21 @@ static void btif_a2dp_data_cb(tUIPC_CH_ID ch_id, tUIPC_EVENT event)
             UIPC_Ioctl(UIPC_CH_ID_AV_AUDIO, UIPC_SET_READ_POLL_TMO,
                        (void *)A2DP_DATA_READ_POLL_MS);
 
+             /*To avoid send request to media task, when media task is shutting down*/
+#if (MTK_COMMON == TRUE)
+            if (media_task_running == MEDIA_TASK_STATE_SHUTTING_DOWN)
+            {
+                APPL_TRACE_DEBUG("media task is shutting down");
+                return;
+            }
+#endif
+
             if (btif_media_cb.peer_sep == AVDT_TSEP_SNK) {
+                /* Start the media task to encode SBC */
+                btif_media_task_start_aa_req();
+
                 /* make sure we update any changed sbc encoder params */
-                /*post a message to btif_av to serialize encode update and encode init*/
-                btif_dispatch_sm_event(BTIF_AV_UPDATE_ENCODER_REQ_EVT, NULL, 0);
+                btif_a2dp_encoder_update();
             }
             btif_media_cb.data_channel_open = TRUE;
 
@@ -1199,46 +1005,6 @@ static void btif_a2dp_data_cb(tUIPC_CH_ID ch_id, tUIPC_EVENT event)
     }
 }
 
-static BOOLEAN btif_media_task_is_aptx_configured()
-{
-    BOOLEAN result = FALSE;
-    UINT8 codectype = bta_av_co_get_current_codec();
-
-    if (codectype == A2D_NON_A2DP_MEDIA_CT) {
-        UINT8* ptr = bta_av_co_get_current_codecInfo();
-        if (ptr) {
-            tA2D_APTX_CIE* codecInfo = (tA2D_APTX_CIE*) &ptr[BTA_AV_CFG_START_IDX];
-            /* Fix for below Klockwork Issue
-             * Pointer 'codecInfo' checked for NULL at line 1089 may be dereferenced at line 1092.*/
-            if ((codecInfo && codecInfo->vendorId == A2D_APTX_VENDOR_ID && codecInfo->codecId == A2D_APTX_CODEC_ID_BLUETOOTH)
-                || (codecInfo && codecInfo->vendorId == A2D_APTX_HD_VENDOR_ID && codecInfo->codecId == A2D_APTX_HD_CODEC_ID_BLUETOOTH)) {
-                APPL_TRACE_DEBUG("%s codecId %d", __func__, codecInfo->codecId);
-                APPL_TRACE_DEBUG("%s vendorId %x", __func__, codecInfo->vendorId);
-                result = TRUE;
-            }
-        }
-    }
-    return result;
-}
-
-A2D_AptXCodecType btif_media_task_get_aptX_codec_type()
-{
-    A2D_AptXCodecType codec = APTX_CODEC_NONE;
-    UINT8 a2dp_codectype = bta_av_co_get_current_codec();
-
-    if (a2dp_codectype == A2D_NON_A2DP_MEDIA_CT) {
-        UINT8* ptr = bta_av_co_get_current_codecInfo();
-        if (ptr) {
-            tA2D_APTX_CIE* codecInfo = (tA2D_APTX_CIE*) &ptr[BTA_AV_CFG_START_IDX];
-            if (codecInfo && codecInfo->vendorId == A2D_APTX_VENDOR_ID && codecInfo->codecId == A2D_APTX_CODEC_ID_BLUETOOTH)
-                codec = APTX_CODEC;
-            else if (codecInfo && codecInfo->vendorId == A2D_APTX_HD_VENDOR_ID && codecInfo->codecId == A2D_APTX_HD_CODEC_ID_BLUETOOTH)
-                codec = APTX_HD_CODEC;
-        }
-    }
-    return codec;
-}
-
 /*****************************************************************************
  **  BTIF ADAPTATION
  *****************************************************************************/
@@ -3522,78 +3288,6 @@ static void btif_media_task_alarm_cb(UNUSED_ATTR void *context) {
   thread_post(worker_thread, btif_media_task_aa_handle_timer, NULL);
 }
 
-int btif_media_task_cb_packet_send(uint8_t* packet, int length, int pcm_bytes_encoded)
-{
-    int bytes_per_frame = 2;
-    uint64_t timestamp_us = 0;
-    UINT8 codectype;
-    codectype = bta_av_co_get_current_codec();
-
-    if (btif_media_task_get_aptX_codec_type() == APTX_HD_CODEC) {
-        bytes_per_frame = 3;
-    }
-
-    if (length > 0 ) {
-
-        if (fixed_queue_length(btif_media_cb.TxAaQ) >= (MAX_OUTPUT_A2DP_FRAME_QUEUE_SZ))
-        {
-            APPL_TRACE_WARNING("%s() - TX queue buffer count %d/%d", __func__,
-                               fixed_queue_length(btif_media_cb.TxAaQ),
-                               MAX_OUTPUT_A2DP_FRAME_QUEUE_SZ);
-            btif_media_cb.stats.tx_queue_dropouts++;
-            timestamp_us = time_now_us();
-            btif_media_cb.stats.tx_queue_last_dropouts_us = timestamp_us;
-        }
-
-        while (fixed_queue_length(btif_media_cb.TxAaQ) >= MAX_OUTPUT_A2DP_FRAME_QUEUE_SZ) {
-            btif_media_cb.stats.tx_queue_total_dropped_messages++;
-            osi_free(fixed_queue_try_dequeue(btif_media_cb.TxAaQ));
-        }
-
-        BT_HDR *p_buf = (BT_HDR *)osi_malloc(BTIF_MEDIA_AA_BUF_SIZE);
-
-        int rtpTimestamp = (pcm_bytes_encoded / btif_media_cb.media_feeding.cfg.pcm.num_channel / bytes_per_frame);
-
-        *((UINT32 *) (p_buf + 1)) = btif_media_cb.timestamp;
-        btif_media_cb.timestamp += rtpTimestamp;
-
-        p_buf->offset = btif_media_cb.offset;
-        p_buf->layer_specific = 0;
-
-        UINT8* ptr = (UINT8*)(p_buf + 1);
-        ptr += p_buf->offset;
-
-        memcpy(ptr, packet, length);
-        p_buf->len = length;
-
-        if (btif_media_cb.tx_flush)
-        {
-            APPL_TRACE_DEBUG("### tx suspended, discarded frame ###");
-
-            btif_media_cb.stats.tx_queue_total_flushed_messages +=
-                fixed_queue_length(btif_media_cb.TxAaQ);
-            btif_media_cb.stats.tx_queue_last_flushed_us =
-                timestamp_us;
-            btif_media_flush_q(btif_media_cb.TxAaQ);
-
-            osi_free(p_buf);
-        } else {
-            update_scheduling_stats(&btif_media_cb.stats.tx_queue_enqueue_stats,
-                                    timestamp_us,
-                                    BTIF_SINK_MEDIA_TIME_TICK_MS * 1000);
-
-            const int BYTES_PER_FRAME = 4;
-            UINT32 frames = pcm_bytes_encoded / BYTES_PER_FRAME;
-            btif_media_cb.stats.tx_queue_total_frames += frames;
-            if (frames > btif_media_cb.stats.tx_queue_max_frames_per_packet)
-                btif_media_cb.stats.tx_queue_max_frames_per_packet = frames;
-            fixed_queue_enqueue(btif_media_cb.TxAaQ, p_buf);
-        }
-
-        bta_av_ci_src_data_ready(BTA_AV_CHNL_AUDIO);
-  }
-  return length;
-}
 /*******************************************************************************
  **
  ** Function         btif_media_task_aa_start_tx
@@ -3605,60 +3299,50 @@ int btif_media_task_cb_packet_send(uint8_t* packet, int length, int pcm_bytes_en
  *******************************************************************************/
 static void btif_media_task_aa_start_tx(void)
 {
-    APPL_TRACE_IMP("%s media_alarm %srunning, feeding mode %d", __func__,
-    alarm_is_scheduled(btif_media_cb.media_alarm)? "" : "not ",
-    btif_media_cb.feeding_mode);
+    APPL_TRACE_DEBUG("%s media_alarm %srunning, feeding mode %d", __func__,
+                     alarm_is_scheduled(btif_media_cb.media_alarm)? "" : "not ",
+                     btif_media_cb.feeding_mode);
+
+#if (MTK_A2DP_SRC_APTX_CODEC == TRUE)
+    UINT8 codecType = bta_av_get_current_codec();
+#endif
+    APPL_TRACE_DEBUG("btif_media_task_aa_start_tx is timer %d, feeding mode %d",
+                     alarm_is_scheduled(btif_media_cb.media_alarm), btif_media_cb.feeding_mode);
 
     last_frame_us = 0;
 
     /* Reset the media feeding state */
     btif_media_task_feeding_state_reset();
 
-    if (!bt_split_a2dp_enabled)
+    APPL_TRACE_EVENT("starting timer %dms", BTIF_MEDIA_TIME_TICK);
+
+#if (MTK_COMMON == TRUE)
+    if(alarm_is_scheduled(btif_media_cb.media_alarm))
     {
-        if (isA2dAptXEnabled && btif_media_task_is_aptx_configured()) {
-#if (BTA_AV_CO_CP_SCMS_T == TRUE)
-          BOOLEAN use_SCMS_T = true;
+        APPL_TRACE_WARNING("btif_media_cb.media_alarm is not null");
+        alarm_free(btif_media_cb.media_alarm);
+        btif_media_cb.media_alarm = NULL;
+    }
 #else
-          BOOLEAN use_SCMS_T = false;
+    alarm_free(btif_media_cb.media_alarm);
 #endif
-          A2D_AptXCodecType aptX_codec_type = btif_media_task_get_aptX_codec_type();
-          BOOLEAN is_24bit_audio = true;
-
-          BOOLEAN test = false;
-          BOOLEAN trace = false;
-
-          A2d_aptx_thread_fn = A2D_aptx_sched_start(btif_media_cb.aptxEncoderParams.encoder,
-                   aptX_codec_type,
-                   use_SCMS_T,
-                   is_24bit_audio,
-                   btif_media_cb.media_feeding.cfg.pcm.sampling_freq,
-                   btif_media_cb.media_feeding.cfg.pcm.bit_per_sample,
-                   UIPC_CH_ID_AV_AUDIO,
-                   btif_media_cb.TxAaMtuSize,
-                   UIPC_Read,
-                   btif_media_task_cb_packet_send,
-                   raise_priority_a2dp,
-                   test,
-                   trace);
-
-          A2d_aptx_thread = thread_new("aptx_media_worker");
-          if (A2d_aptx_thread ) {
-             thread_post(A2d_aptx_thread, A2d_aptx_thread_fn, NULL);
-          }
-        } else {
-            APPL_TRACE_EVENT("starting timer %dms", BTIF_MEDIA_TIME_TICK);
 
-            alarm_free(btif_media_cb.media_alarm);
-            btif_media_cb.media_alarm = alarm_new_periodic("btif.media_task");
-            if (!btif_media_cb.media_alarm) {
-              LOG_ERROR(LOG_TAG, "%s unable to allocate media alarm.", __func__);
-              return;
-            }
+    btif_media_cb.media_alarm = alarm_new_periodic("btif.media_task");
+    if (!btif_media_cb.media_alarm) {
+      LOG_ERROR(LOG_TAG, "%s unable to allocate media alarm.", __func__);
+      return;
+    }
 
-            alarm_set(btif_media_cb.media_alarm, BTIF_MEDIA_TIME_TICK,
-                      btif_media_task_alarm_cb, NULL);
-        }
+
+#if (MTK_A2DP_SRC_APTX_CODEC == TRUE)
+    if(codecType == NON_A2DP_MEDIA_CT)
+    {
+        alarm_set(btif_media_cb.media_alarm, BTIF_MEDIA_TIME_TICK /MTK_A2DP_BTIF_MEDIA_TIME_EXT , btif_media_task_alarm_cb, NULL);
+    }
+    else
+#endif
+    {
+        alarm_set(btif_media_cb.media_alarm, BTIF_MEDIA_TIME_TICK, btif_media_task_alarm_cb, NULL);
     }
 }
 
